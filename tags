!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	./apps/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
A	./apps/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
A	./apps/utils.h	/^    ET* A;$/;"	m	struct:sequence::getA
A	./apps/utils.h	/^    IT* A;$/;"	m	struct:sequence::getAF
A	./apps/utils.h	/^    bool* A;$/;"	m	struct:sequence::boolGetA
A	./apps/utils.h	/^  T* A;$/;"	m	struct:_seq
A	./ligra/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
A	./ligra/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
A	./ligra/utils.h	/^    ET* A;$/;"	m	struct:sequence::getA
A	./ligra/utils.h	/^    IT* A;$/;"	m	struct:sequence::getAF
A	./ligra/utils.h	/^    bool* A;$/;"	m	struct:sequence::boolGetA
A	./ligra/utils.h	/^  T* A;$/;"	m	struct:_seq
A	./tutorial/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
A	./tutorial/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
A	./tutorial/utils.h	/^    ET* A;$/;"	m	struct:sequence::getA
A	./tutorial/utils.h	/^    IT* A;$/;"	m	struct:sequence::getAF
A	./tutorial/utils.h	/^    bool* A;$/;"	m	struct:sequence::boolGetA
A	./tutorial/utils.h	/^  T* A;$/;"	m	struct:_seq
A	./utils/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
A	./utils/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
A	./utils/utils.h	/^    ET* A;$/;"	m	struct:sequence::getA
A	./utils/utils.h	/^    IT* A;$/;"	m	struct:sequence::getAF
A	./utils/utils.h	/^    bool* A;$/;"	m	struct:sequence::boolGetA
A	./utils/utils.h	/^  T* A;$/;"	m	struct:_seq
ACL_F	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  ACL_F(sparseAdditiveSet<float> &_p, sparseAdditiveSet<float> &_r, sparseAdditiveSet<float> &_new_r, vertex* _V, double _alpha) : $/;"	f	struct:ACL_F
ACL_F	./apps/localAlg/ACL-Sync-Local-Opt.C	/^struct ACL_F {$/;"	s	file:
ACL_F	./apps/localAlg/ACL-Sync-Local.C	/^  ACL_F(sparseAdditiveSet<float> &_p, sparseAdditiveSet<float> &_r, sparseAdditiveSet<float> &_new_r, vertex* _V, double _oneMinusAlphaOverTwo) : $/;"	f	struct:ACL_F
ACL_F	./apps/localAlg/ACL-Sync-Local.C	/^struct ACL_F {$/;"	s	file:
ACLpair	./apps/localAlg/ACL-Sync-Local-Opt.C	/^typedef pair<uintE,float> ACLpair;$/;"	t	file:
ACLpair	./apps/localAlg/ACL-Sync-Local.C	/^typedef pair<uintE,float> ACLpair;$/;"	t	file:
ACLpair	./apps/localAlg/HeatKernel-Parallel.C	/^typedef pair<uintE,float> ACLpair;$/;"	t	file:
ACLpair	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^typedef pair<uintE,double> ACLpair;$/;"	t	file:
ACLpair	./apps/localAlg/Nibble-Parallel.C	/^typedef pair<uintE,float> ACLpair;$/;"	t	file:
ALL	./apps/Makefile	/^ALL=MaxDegree$/;"	m
ALL	./apps/eccentricity/Makefile	/^ALL= kBFS-1Phase-Ecc kBFS-Ecc FM-Ecc LogLog-Ecc kBFS-Exact RV CLRSTV TK Simple-Approx-Ecc$/;"	m
ALL	./tutorial/Makefile	/^ALL= encoder BFS BellmanFord Components Radii KCore$/;"	m
AVG_SEG_SIZE	./apps/localAlg/sampleSort.h	53;"	d
A_QSORT_INCLUDED	./apps/quickSort.h	24;"	d
A_QSORT_INCLUDED	./ligra/quickSort.h	24;"	d
A_QSORT_INCLUDED	./tutorial/quickSort.h	24;"	d
A_QSORT_INCLUDED	./utils/quickSort.h	24;"	d
A_RADIX_INCLUDED	./apps/blockRadixSort.h	24;"	d
A_RADIX_INCLUDED	./ligra/blockRadixSort.h	24;"	d
A_RADIX_INCLUDED	./tutorial/blockRadixSort.h	24;"	d
A_RADIX_INCLUDED	./utils/blockRadixSort.h	24;"	d
A_TRANSPOSE_INCLUDED	./apps/transpose.h	24;"	d
A_TRANSPOSE_INCLUDED	./ligra/transpose.h	24;"	d
A_TRANSPOSE_INCLUDED	./tutorial/transpose.h	24;"	d
A_TRANSPOSE_INCLUDED	./utils/transpose.h	24;"	d
B	./apps/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
B	./apps/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
B	./ligra/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
B	./ligra/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
B	./tutorial/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
B	./tutorial/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
B	./utils/transpose.h	/^  E *A, *B;$/;"	m	struct:blockTrans
B	./utils/transpose.h	/^  E *A, *B;$/;"	m	struct:transpose
BC_Back_F	./apps/BC.C	/^  BC_Back_F(fType* _Dependencies, bool* _Visited) : $/;"	f	struct:BC_Back_F
BC_Back_F	./apps/BC.C	/^struct BC_Back_F {$/;"	s	file:
BC_Back_Vertex_F	./apps/BC.C	/^  BC_Back_Vertex_F(bool* _Visited, fType* _Dependencies, fType* _inverseNumPaths) : $/;"	f	struct:BC_Back_Vertex_F
BC_Back_Vertex_F	./apps/BC.C	/^struct BC_Back_Vertex_F {$/;"	s	file:
BC_F	./apps/BC.C	/^  BC_F(fType* _NumPaths, bool* _Visited) : $/;"	f	struct:BC_F
BC_F	./apps/BC.C	/^struct BC_F {$/;"	s	file:
BC_Vertex_F	./apps/BC.C	/^  BC_Vertex_F(bool* _Visited) : Visited(_Visited) {}$/;"	f	struct:BC_Vertex_F
BC_Vertex_F	./apps/BC.C	/^struct BC_Vertex_F {$/;"	s	file:
BFS_F	./apps/BFS-Bitvector.C	/^  BFS_F(uintE* _Parents, long* _Visited) $/;"	f	struct:BFS_F
BFS_F	./apps/BFS-Bitvector.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./apps/BFS.C	/^  BFS_F(uintE* _Parents) : Parents(_Parents) {}$/;"	f	struct:BFS_F
BFS_F	./apps/BFS.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./apps/BFSCC.C	/^  BFS_F(uintE* _Parents, uintE _label) : Parents(_Parents), label(_label) {}$/;"	f	struct:BFS_F
BFS_F	./apps/BFSCC.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./apps/MaxDegree.C	/^  BFS_F(uintE* _Parents) : Parents(_Parents) {}$/;"	f	struct:BFS_F
BFS_F	./apps/MaxDegree.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./apps/eccentricity/CLRSTV.C	/^  BFS_F(uintE* _Dist, uintE _round) : Dist(_Dist), round(_round) {}$/;"	f	struct:BFS_F
BFS_F	./apps/eccentricity/CLRSTV.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./apps/eccentricity/RV.C	/^  BFS_F(uintE* _Dist, uintE _round) : Dist(_Dist), round(_round) {}$/;"	f	struct:BFS_F
BFS_F	./apps/eccentricity/RV.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./apps/eccentricity/Simple-Approx-Ecc.C	/^  BFS_F(uintE* _Dist, uintE _round) : Dist(_Dist), round(_round) {}$/;"	f	struct:BFS_F
BFS_F	./apps/eccentricity/Simple-Approx-Ecc.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./apps/eccentricity/TK.C	/^  BFS_F(uintE* _Dist, uintE _round) : Dist(_Dist), round(_round) {}$/;"	f	struct:BFS_F
BFS_F	./apps/eccentricity/TK.C	/^struct BFS_F {$/;"	s	file:
BFS_F	./tutorial/BFS.C	/^  BFS_F(long* _Parents) : Parents(_Parents) {}$/;"	f	struct:BFS_F
BFS_F	./tutorial/BFS.C	/^struct BFS_F {$/;"	s	file:
BFS_Pair_F	./apps/eccentricity/RV.C	/^  BFS_Pair_F(intPair* _Dist, uintE _round) : Dist(_Dist), round(_round) {}$/;"	f	struct:BFS_Pair_F
BFS_Pair_F	./apps/eccentricity/RV.C	/^struct BFS_Pair_F {$/;"	s	file:
BF_F	./apps/BellmanFord.C	/^  BF_F(intE* _ShortestPathLen, int* _Visited) : $/;"	f	struct:BF_F
BF_F	./apps/BellmanFord.C	/^struct BF_F {$/;"	s	file:
BF_F	./tutorial/BellmanFord.C	/^  BF_F(long* _ShortestPathLen) : $/;"	f	struct:BF_F
BF_F	./tutorial/BellmanFord.C	/^struct BF_F {$/;"	s	file:
BF_Vertex_F	./apps/BellmanFord.C	/^  BF_Vertex_F(int* _Visited) : Visited(_Visited) {}$/;"	f	struct:BF_Vertex_F
BF_Vertex_F	./apps/BellmanFord.C	/^struct BF_Vertex_F {$/;"	s	file:
BUCKETS	./apps/blockRadixSort.h	49;"	d
BUCKETS	./ligra/blockRadixSort.h	49;"	d
BUCKETS	./tutorial/blockRadixSort.h	49;"	d
BUCKETS	./utils/blockRadixSort.h	49;"	d
BYTECODE_H	./apps/byte-pd.h	25;"	d
BYTECODE_H	./apps/byte.h	25;"	d
BYTECODE_H	./apps/byteRLE-pd.h	25;"	d
BYTECODE_H	./apps/byteRLE.h	25;"	d
BYTECODE_H	./apps/nibble-pd.h	25;"	d
BYTECODE_H	./apps/nibble.h	25;"	d
BYTECODE_H	./ligra/byte-pd.h	25;"	d
BYTECODE_H	./ligra/byte.h	25;"	d
BYTECODE_H	./ligra/byteRLE-pd.h	25;"	d
BYTECODE_H	./ligra/byteRLE.h	25;"	d
BYTECODE_H	./ligra/nibble-pd.h	25;"	d
BYTECODE_H	./ligra/nibble.h	25;"	d
BYTECODE_H	./tutorial/byte-pd.h	25;"	d
BYTECODE_H	./tutorial/byte.h	25;"	d
BYTECODE_H	./tutorial/byteRLE-pd.h	25;"	d
BYTECODE_H	./tutorial/byteRLE.h	25;"	d
BYTECODE_H	./tutorial/nibble-pd.h	25;"	d
BYTECODE_H	./tutorial/nibble.h	25;"	d
CAS	./apps/utils.h	/^inline bool CAS(ET *ptr, ET oldv, ET newv) {$/;"	f
CAS	./ligra/utils.h	/^inline bool CAS(ET *ptr, ET oldv, ET newv) {$/;"	f
CAS	./tutorial/utils.h	/^inline bool CAS(ET *ptr, ET oldv, ET newv) {$/;"	f
CAS	./utils/utils.h	/^inline bool CAS(ET *ptr, ET oldv, ET newv) {$/;"	f
CCBFS	./apps/eccentricity/CCBFS.h	/^uintE CCBFS(intE start, graph<vertex> GA, intE* Labels) {$/;"	f
CCBFS_F	./apps/eccentricity/CCBFS.h	/^CCBFS_F(intE _label, intE* _Labels) : label(_label), Labels(_Labels) {}$/;"	f	struct:CCBFS_F
CCBFS_F	./apps/eccentricity/CCBFS.h	/^struct CCBFS_F {$/;"	s
CC_F	./apps/Components.C	/^  CC_F(uintE* _IDs, uintE* _prevIDs) : $/;"	f	struct:CC_F
CC_F	./apps/Components.C	/^struct CC_F {$/;"	s	file:
CC_F	./apps/eccentricity/CCBFS.h	/^  CC_F(intE* _IDs, intE* _prevIDs) : $/;"	f	struct:CC_F
CC_F	./apps/eccentricity/CCBFS.h	/^struct CC_F {$/;"	s
CC_F	./tutorial/Components.C	/^  CC_F(long* _IDs) : IDs(_IDs) {}$/;"	f	struct:CC_F
CC_F	./tutorial/Components.C	/^struct CC_F {$/;"	s	file:
CC_Vertex_F	./apps/Components.C	/^  CC_Vertex_F(uintE* _IDs, uintE* _prevIDs) :$/;"	f	struct:CC_Vertex_F
CC_Vertex_F	./apps/Components.C	/^struct CC_Vertex_F {$/;"	s	file:
CC_Vertex_F	./apps/eccentricity/CCBFS.h	/^CC_Vertex_F(intE* _IDs, intE* _prevIDs) :$/;"	f	struct:CC_Vertex_F
CC_Vertex_F	./apps/eccentricity/CCBFS.h	/^struct CC_Vertex_F {$/;"	s
CF_Edge_F	./apps/CF.C	/^  CF_Edge_F(vertex* _V, double* _latent_curr, double* _error, int _K) : $/;"	f	struct:CF_Edge_F
CF_Edge_F	./apps/CF.C	/^struct CF_Edge_F {$/;"	s	file:
CF_Vertex_F	./apps/CF.C	/^  CF_Vertex_F(double _step, double _lambda, double* _latent_curr, double* _error, int _K) :$/;"	f	struct:CF_Vertex_F
CF_Vertex_F	./apps/CF.C	/^struct CF_Vertex_F {$/;"	s	file:
CODE	./apps/Makefile	/^CODE = -DBYTE$/;"	m
CODE	./apps/Makefile	/^CODE = -DBYTERLE$/;"	m
CODE	./apps/Makefile	/^CODE = -DNIBBLE$/;"	m
COMMON	./apps/Makefile	/^COMMON= ligra.h graph.h compressedVertex.h vertex.h utils.h IO.h parallel.h gettime.h quickSort.h blockRadixSort.h transpose.h parseCommandLine.h byte.h byteRLE.h nibble.h byte-pd.h byteRLE-pd.h nibble-pd.h vertexSubset.h encoder.C$/;"	m
COMMON	./apps/eccentricity/Makefile	/^COMMON= ligra.h graph.h compressedVertex.h vertex.h utils.h IO.h parallel.h gettime.h quickSort.h parseCommandLine.h byte.h byteRLE.h nibble.h byte-pd.h byteRLE-pd.h nibble-pd.h vertexSubset.h encoder.C$/;"	m
COMMON	./apps/localAlg/Makefile	/^COMMON= ligra.h graph.h compressedVertex.h vertex.h utils.h IO.h parallel.h gettime.h quickSort.h parseCommandLine.h byte.h byteRLE.h nibble.h byte-pd.h byteRLE-pd.h nibble-pd.h vertexSubset.h encoder.C$/;"	m
COMMON	./tutorial/Makefile	/^COMMON= ligra.h graph.h compressedVertex.h vertex.h utils.h IO.h parallel.h gettime.h quickSort.h parseCommandLine.h byte.h byteRLE.h nibble.h byte-pd.h byteRLE-pd.h nibble-pd.h vertexSubset.h encoder.C blockRadixSort.h transpose.h$/;"	m
COMMON	./utils/Makefile	/^COMMON = utils.h parseCommandLine.h parallel.h quickSort.h blockRadixSort.h transpose.h$/;"	m
COMPRESSED_VERTEX_H	./apps/compressedVertex.h	2;"	d
COMPRESSED_VERTEX_H	./ligra/compressedVertex.h	2;"	d
COMPRESSED_VERTEX_H	./tutorial/compressedVertex.h	2;"	d
CONDITIONALLY_IN	./apps/MIS.C	/^enum {UNDECIDED,CONDITIONALLY_IN,OUT,IN};$/;"	e	enum:__anon1	file:
Chars	./apps/IO.h	/^  char* Chars;  \/\/ array storing all strings$/;"	m	struct:words
Chars	./ligra/IO.h	/^  char* Chars;  \/\/ array storing all strings$/;"	m	struct:words
Chars	./tutorial/IO.h	/^  char* Chars;  \/\/ array storing all strings$/;"	m	struct:words
Chars	./utils/graphIO.h	/^    char* Chars;  \/\/ array storing all strings$/;"	m	struct:benchIO::words
Components	./apps/eccentricity/CCBFS.h	/^void Components(graph<vertex> GA, intE* IDs) {$/;"	f
Compressed_Mem	./apps/IO.h	/^  Compressed_Mem(vertex* _V, long _n, long _m, uintT* _inOffsets, uintT* _offsets, uchar* _inEdges, $/;"	f	struct:Compressed_Mem
Compressed_Mem	./apps/IO.h	/^struct Compressed_Mem : public Deletable {$/;"	s
Compressed_Mem	./ligra/IO.h	/^  Compressed_Mem(vertex* _V, long _n, long _m, uintT* _inOffsets, uintT* _offsets, uchar* _inEdges, $/;"	f	struct:Compressed_Mem
Compressed_Mem	./ligra/IO.h	/^struct Compressed_Mem : public Deletable {$/;"	s
Compressed_Mem	./tutorial/IO.h	/^  Compressed_Mem(vertex* _V, long _n, long _m, uintT* _inOffsets, uintT* _offsets, uchar* _inEdges, $/;"	f	struct:Compressed_Mem
Compressed_Mem	./tutorial/IO.h	/^struct Compressed_Mem : public Deletable {$/;"	s
Compute	./apps/BC.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/BFS-Bitvector.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/BFS.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/BFSCC.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/BellmanFord.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/CF.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/Components.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/KCore.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/MCE.C	/^void Compute(graph<vertex>& GA, commandLine P){$/;"	f
Compute	./apps/MIS.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/MaxDegree.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/PageRank.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/PageRankDelta.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/Radii.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/Triangle.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/CLRSTV.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/FM-Ecc.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/LogLog-Ecc.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/RV.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/Simple-Approx-Ecc.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/TK.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/kBFS-Ecc.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/eccentricity/kBFS-Exact.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/ACL-Serial-Naive.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/ACL-Serial-Opt-Naive.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/ACL-Serial-Opt.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/ACL-Serial.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/ACL-Sync-Local-Opt.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/ACL-Sync-Local.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/HeatKernel-Parallel.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/HeatKernel-Randomized-Serial.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/HeatKernel-Serial.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/Nibble-Parallel.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./apps/localAlg/Nibble-Serial.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./tutorial/BFS.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./tutorial/BellmanFord.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./tutorial/Components.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./tutorial/KCore.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
Compute	./tutorial/Radii.C	/^void Compute(graph<vertex>& GA, commandLine P) {$/;"	f
D	./apps/graph.h	/^  Deletable *D;$/;"	m	struct:graph
D	./ligra/graph.h	/^  Deletable *D;$/;"	m	struct:graph
D	./tutorial/graph.h	/^  Deletable *D;$/;"	m	struct:graph
DENSE	./apps/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	e	enum:options
DENSE	./ligra/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	e	enum:options
DENSE	./tutorial/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	e	enum:options
DENSE_FORWARD	./apps/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	e	enum:options
DENSE_FORWARD	./ligra/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	e	enum:options
DENSE_FORWARD	./tutorial/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	e	enum:options
Deg_AtLeast_K	./apps/KCore.C	/^  Deg_AtLeast_K(vertex* _V, intE* _Degrees, uintE _k) : $/;"	f	struct:Deg_AtLeast_K
Deg_AtLeast_K	./apps/KCore.C	/^struct Deg_AtLeast_K {$/;"	s	file:
Deg_AtLeast_K	./tutorial/KCore.C	/^  Deg_AtLeast_K(vertex* _V, long* _Degrees, long _k) : $/;"	f	struct:Deg_AtLeast_K
Deg_AtLeast_K	./tutorial/KCore.C	/^struct Deg_AtLeast_K {$/;"	s	file:
Deg_LessThan_K	./apps/KCore.C	/^  Deg_LessThan_K(vertex* _V, intE* _Degrees, uintE* _coreNumbers, uintE _k) : $/;"	f	struct:Deg_LessThan_K
Deg_LessThan_K	./apps/KCore.C	/^struct Deg_LessThan_K {$/;"	s	file:
Deg_LessThan_K	./tutorial/KCore.C	/^  Deg_LessThan_K(vertex* _V, long* _Degrees, long* _coreNumbers, long _k) : $/;"	f	struct:Deg_LessThan_K
Deg_LessThan_K	./tutorial/KCore.C	/^struct Deg_LessThan_K {$/;"	s	file:
Degrees	./apps/IO.h	/^  uintE* Degrees;$/;"	m	struct:Compressed_Mem
Degrees	./apps/KCore.C	/^  intE *Degrees;$/;"	m	struct:Deg_AtLeast_K	file:
Degrees	./apps/KCore.C	/^  intE* Degrees;$/;"	m	struct:Deg_LessThan_K	file:
Degrees	./apps/KCore.C	/^  intE* Degrees;$/;"	m	struct:Update_Deg	file:
Degrees	./ligra/IO.h	/^  uintE* Degrees;$/;"	m	struct:Compressed_Mem
Degrees	./tutorial/IO.h	/^  uintE* Degrees;$/;"	m	struct:Compressed_Mem
Degrees	./tutorial/KCore.C	/^  long *Degrees;$/;"	m	struct:Deg_AtLeast_K	file:
Degrees	./tutorial/KCore.C	/^  long* Degrees;$/;"	m	struct:Deg_LessThan_K	file:
Degrees	./tutorial/KCore.C	/^  long* Degrees;$/;"	m	struct:Update_Deg	file:
Deletable	./apps/graph.h	/^struct Deletable {$/;"	s
Deletable	./ligra/graph.h	/^struct Deletable {$/;"	s
Deletable	./tutorial/graph.h	/^struct Deletable {$/;"	s
Delta	./apps/PageRankDelta.C	/^  double* Delta, *nghSum;$/;"	m	struct:PR_F	file:
Delta	./apps/PageRankDelta.C	/^  double* p, *Delta, *nghSum;$/;"	m	struct:PR_Vertex_F	file:
Delta	./apps/PageRankDelta.C	/^  double* p, *Delta, *nghSum;$/;"	m	struct:PR_Vertex_F_FirstRound	file:
Dependencies	./apps/BC.C	/^  fType* Dependencies, *inverseNumPaths;$/;"	m	struct:BC_Back_Vertex_F	file:
Dependencies	./apps/BC.C	/^  fType* Dependencies;$/;"	m	struct:BC_Back_F	file:
Dist	./apps/eccentricity/CLRSTV.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
Dist	./apps/eccentricity/RV.C	/^  intPair* Dist; uintE round;$/;"	m	struct:BFS_Pair_F	file:
Dist	./apps/eccentricity/RV.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
Dist	./apps/eccentricity/Simple-Approx-Ecc.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
Dist	./apps/eccentricity/TK.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
E	./utils/graphIO.h	/^  edge<intT>* E;$/;"	m	struct:edgeArray
EDGE_SIZE_PER_BYTE	./apps/byte-pd.h	39;"	d
EDGE_SIZE_PER_BYTE	./apps/byte.h	37;"	d
EDGE_SIZE_PER_BYTE	./apps/byteRLE-pd.h	37;"	d
EDGE_SIZE_PER_BYTE	./apps/byteRLE.h	39;"	d
EDGE_SIZE_PER_BYTE	./apps/nibble-pd.h	42;"	d
EDGE_SIZE_PER_BYTE	./apps/nibble.h	40;"	d
EDGE_SIZE_PER_BYTE	./ligra/byte-pd.h	39;"	d
EDGE_SIZE_PER_BYTE	./ligra/byte.h	37;"	d
EDGE_SIZE_PER_BYTE	./ligra/byteRLE-pd.h	37;"	d
EDGE_SIZE_PER_BYTE	./ligra/byteRLE.h	39;"	d
EDGE_SIZE_PER_BYTE	./ligra/nibble-pd.h	42;"	d
EDGE_SIZE_PER_BYTE	./ligra/nibble.h	40;"	d
EDGE_SIZE_PER_BYTE	./tutorial/byte-pd.h	39;"	d
EDGE_SIZE_PER_BYTE	./tutorial/byte.h	37;"	d
EDGE_SIZE_PER_BYTE	./tutorial/byteRLE-pd.h	37;"	d
EDGE_SIZE_PER_BYTE	./tutorial/byteRLE.h	39;"	d
EDGE_SIZE_PER_BYTE	./tutorial/nibble-pd.h	42;"	d
EDGE_SIZE_PER_BYTE	./tutorial/nibble.h	40;"	d
Ecc_F	./apps/eccentricity/FM-Ecc.C	/^  Ecc_F(long _length, intE* _Visited, intE* _NextVisited, $/;"	f	struct:Ecc_F
Ecc_F	./apps/eccentricity/FM-Ecc.C	/^struct Ecc_F {$/;"	s	file:
Ecc_F	./apps/eccentricity/LogLog-Ecc.C	/^  Ecc_F(long _length, long* _Visited, long* _NextVisited, $/;"	f	struct:Ecc_F
Ecc_F	./apps/eccentricity/LogLog-Ecc.C	/^struct Ecc_F {$/;"	s	file:
Ecc_F	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  Ecc_F(const long _length, long* _Visited, long* _NextVisited, $/;"	f	struct:Ecc_F
Ecc_F	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^struct Ecc_F {$/;"	s	file:
Ecc_F	./apps/eccentricity/kBFS-Ecc.C	/^  Ecc_F(const long _length, long* _Visited, long* _NextVisited, $/;"	f	struct:Ecc_F
Ecc_F	./apps/eccentricity/kBFS-Ecc.C	/^struct Ecc_F {$/;"	s	file:
Ecc_F	./apps/eccentricity/kBFS-Exact.C	/^  Ecc_F(long _length, long* _Visited, long* _NextVisited, $/;"	f	struct:Ecc_F
Ecc_F	./apps/eccentricity/kBFS-Exact.C	/^struct Ecc_F {$/;"	s	file:
Ecc_Vertex_F	./apps/eccentricity/FM-Ecc.C	/^  Ecc_Vertex_F(long _length, intE* _Visited, intE* _NextVisited) :$/;"	f	struct:Ecc_Vertex_F
Ecc_Vertex_F	./apps/eccentricity/FM-Ecc.C	/^struct Ecc_Vertex_F {$/;"	s	file:
Ecc_Vertex_F	./apps/eccentricity/LogLog-Ecc.C	/^  Ecc_Vertex_F(long _length, long* _Visited, long* _NextVisited) :$/;"	f	struct:Ecc_Vertex_F
Ecc_Vertex_F	./apps/eccentricity/LogLog-Ecc.C	/^struct Ecc_Vertex_F {$/;"	s	file:
Ecc_Vertex_F	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  Ecc_Vertex_F(const long _length, long* _Visited, long* _NextVisited) :$/;"	f	struct:Ecc_Vertex_F
Ecc_Vertex_F	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^struct Ecc_Vertex_F {$/;"	s	file:
Ecc_Vertex_F	./apps/eccentricity/kBFS-Ecc.C	/^  Ecc_Vertex_F(const long _length, long* _Visited, long* _NextVisited) :$/;"	f	struct:Ecc_Vertex_F
Ecc_Vertex_F	./apps/eccentricity/kBFS-Ecc.C	/^struct Ecc_Vertex_F {$/;"	s	file:
Ecc_Vertex_F	./apps/eccentricity/kBFS-Exact.C	/^  Ecc_Vertex_F(long _length, long* _Visited, long* _NextVisited) :$/;"	f	struct:Ecc_Vertex_F
Ecc_Vertex_F	./apps/eccentricity/kBFS-Exact.C	/^struct Ecc_Vertex_F {$/;"	s	file:
GENERATORS	./utils/Makefile	/^GENERATORS = rMatGraph gridGraph randLocalGraph SNAPtoAdj adjGraphAddWeights adjToBinary$/;"	m
GRAPH_H	./apps/graph.h	2;"	d
GRAPH_H	./ligra/graph.h	2;"	d
GRAPH_H	./tutorial/graph.h	2;"	d
H6	./apps/eccentricity/LogLog-Ecc.C	31;"	d	file:
H6_comp	./apps/eccentricity/LogLog-Ecc.C	32;"	d	file:
HK_F	./apps/localAlg/HeatKernel-Parallel.C	/^  HK_F(sparseAdditiveSet<float> &_x, sparseAdditiveSet<float> &_r, sparseAdditiveSet<float> &_new_r, vertex* _V, double _toverjplus1) : $/;"	f	struct:HK_F
HK_F	./apps/localAlg/HeatKernel-Parallel.C	/^struct HK_F {$/;"	s	file:
HK_Last_F	./apps/localAlg/HeatKernel-Parallel.C	/^  HK_Last_F(sparseAdditiveSet<float> &_x, sparseAdditiveSet<float> &_r, vertex* _V) : $/;"	f	struct:HK_Last_F
HK_Last_F	./apps/localAlg/HeatKernel-Parallel.C	/^struct HK_Last_F {$/;"	s	file:
IDs	./apps/Components.C	/^  uintE* IDs, *prevIDs;$/;"	m	struct:CC_F	file:
IDs	./apps/Components.C	/^  uintE* IDs, *prevIDs;$/;"	m	struct:CC_Vertex_F	file:
IDs	./apps/eccentricity/CCBFS.h	/^  intE* IDs, *prevIDs;$/;"	m	struct:CC_F
IDs	./apps/eccentricity/CCBFS.h	/^  intE* IDs, *prevIDs;$/;"	m	struct:CC_Vertex_F
IDs	./tutorial/Components.C	/^  long* IDs;$/;"	m	struct:CC_F	file:
IN	./apps/MIS.C	/^enum {UNDECIDED,CONDITIONALLY_IN,OUT,IN};$/;"	e	enum:__anon1	file:
INTE	./apps/Makefile	/^INTE = -DEDGELONG$/;"	m
INTE	./apps/eccentricity/Makefile	/^INTE = -DEDGELONG$/;"	m
INTE	./apps/localAlg/Makefile	/^INTE = -DEDGELONG$/;"	m
INTE	./tutorial/Makefile	/^INTE = -DEDGELONG$/;"	m
INTE	./utils/Makefile	/^INTE = -DEDGELONG$/;"	m
INTSORT	./apps/eccentricity/Makefile	/^INTSORT= blockRadixSort.h transpose.h$/;"	m
INTSORT	./apps/localAlg/Makefile	/^INTSORT= blockRadixSort.h transpose.h$/;"	m
INTT	./apps/Makefile	/^INTT = -DLONG$/;"	m
INTT	./apps/eccentricity/Makefile	/^INTT = -DLONG$/;"	m
INTT	./apps/localAlg/Makefile	/^INTT = -DLONG$/;"	m
INTT	./tutorial/Makefile	/^INTT = -DLONG$/;"	m
INTT	./utils/Makefile	/^INTT = -DLONG$/;"	m
INT_E_MAX	./apps/parallel.h	118;"	d
INT_E_MAX	./apps/parallel.h	123;"	d
INT_E_MAX	./ligra/parallel.h	118;"	d
INT_E_MAX	./ligra/parallel.h	123;"	d
INT_E_MAX	./tutorial/parallel.h	118;"	d
INT_E_MAX	./tutorial/parallel.h	123;"	d
INT_E_MAX	./utils/parallel.h	118;"	d
INT_E_MAX	./utils/parallel.h	123;"	d
INT_T_MAX	./apps/parallel.h	105;"	d
INT_T_MAX	./apps/parallel.h	110;"	d
INT_T_MAX	./ligra/parallel.h	105;"	d
INT_T_MAX	./ligra/parallel.h	110;"	d
INT_T_MAX	./tutorial/parallel.h	105;"	d
INT_T_MAX	./tutorial/parallel.h	110;"	d
INT_T_MAX	./utils/parallel.h	105;"	d
INT_T_MAX	./utils/parallel.h	110;"	d
IOFileNames	./apps/parseCommandLine.h	/^  pair<char*,char*> IOFileNames() {$/;"	f	struct:commandLine
IOFileNames	./ligra/parseCommandLine.h	/^  pair<char*,char*> IOFileNames() {$/;"	f	struct:commandLine
IOFileNames	./tutorial/parseCommandLine.h	/^  pair<char*,char*> IOFileNames() {$/;"	f	struct:commandLine
IOFileNames	./utils/parseCommandLine.h	/^  pair<char*,char*> IOFileNames() {$/;"	f	struct:commandLine
ISORT	./apps/quickSort.h	38;"	d
ISORT	./ligra/quickSort.h	38;"	d
ISORT	./tutorial/quickSort.h	38;"	d
ISORT	./utils/quickSort.h	38;"	d
K	./apps/CF.C	/^  int K;$/;"	m	struct:CF_Edge_F	file:
K	./apps/CF.C	/^  int K;$/;"	m	struct:CF_Vertex_F	file:
Kminus1	./apps/eccentricity/LogLog-Ecc.C	29;"	d	file:
L	./apps/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
L	./ligra/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
L	./tutorial/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
L	./utils/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
L6	./apps/eccentricity/LogLog-Ecc.C	30;"	d	file:
LAST_BIT_SET	./apps/byte-pd.h	38;"	d
LAST_BIT_SET	./apps/byte.h	36;"	d
LAST_BIT_SET	./apps/byteRLE-pd.h	36;"	d
LAST_BIT_SET	./apps/byteRLE.h	38;"	d
LAST_BIT_SET	./apps/nibble-pd.h	41;"	d
LAST_BIT_SET	./apps/nibble.h	39;"	d
LAST_BIT_SET	./ligra/byte-pd.h	38;"	d
LAST_BIT_SET	./ligra/byte.h	36;"	d
LAST_BIT_SET	./ligra/byteRLE-pd.h	36;"	d
LAST_BIT_SET	./ligra/byteRLE.h	38;"	d
LAST_BIT_SET	./ligra/nibble-pd.h	41;"	d
LAST_BIT_SET	./ligra/nibble.h	39;"	d
LAST_BIT_SET	./tutorial/byte-pd.h	38;"	d
LAST_BIT_SET	./tutorial/byte.h	36;"	d
LAST_BIT_SET	./tutorial/byteRLE-pd.h	36;"	d
LAST_BIT_SET	./tutorial/byteRLE.h	38;"	d
LAST_BIT_SET	./tutorial/nibble-pd.h	41;"	d
LAST_BIT_SET	./tutorial/nibble.h	39;"	d
LIGRA_H	./apps/ligra.h	25;"	d
LIGRA_H	./ligra/ligra.h	25;"	d
LIGRA_H	./tutorial/ligra.h	25;"	d
LOAD_FACTOR	./apps/localAlg/ACL-Sync-Local-Opt.C	76;"	d	file:
LOAD_FACTOR	./apps/localAlg/ACL-Sync-Local.C	76;"	d	file:
LOAD_FACTOR	./apps/localAlg/HeatKernel-Parallel.C	92;"	d	file:
LOAD_FACTOR	./apps/localAlg/Nibble-Parallel.C	71;"	d	file:
LOCAL_COMMON	./apps/localAlg/Makefile	/^LOCAL_COMMON = sweep.h sparseSet.h sampleSort.h$/;"	m
LOCAL_COMMON	./utils/Makefile	/^LOCAL_COMMON = graphIO.h$/;"	m
Labels	./apps/eccentricity/CCBFS.h	/^  intE* Labels;$/;"	m	struct:CCBFS_F
Local_Update	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  Local_Update(sparseAdditiveSet<float> &_p, sparseAdditiveSet<float> &_r, double _alpha) :$/;"	f	struct:Local_Update
Local_Update	./apps/localAlg/ACL-Sync-Local-Opt.C	/^struct Local_Update {$/;"	s	file:
Local_Update	./apps/localAlg/ACL-Sync-Local.C	/^  Local_Update(sparseAdditiveSet<float> &_p, sparseAdditiveSet<float> &_r, double _alpha) :$/;"	f	struct:Local_Update
Local_Update	./apps/localAlg/ACL-Sync-Local.C	/^struct Local_Update {$/;"	s	file:
Local_Update	./apps/localAlg/HeatKernel-Parallel.C	/^  Local_Update(sparseAdditiveSet<float> &_x, sparseAdditiveSet<float> &_r) :$/;"	f	struct:Local_Update
Local_Update	./apps/localAlg/HeatKernel-Parallel.C	/^struct Local_Update {$/;"	s	file:
Local_Update	./apps/localAlg/Nibble-Parallel.C	/^  Local_Update(sparseAdditiveSet<float> &_p, sparseAdditiveSet<float> &_new_p) :$/;"	f	struct:Local_Update
Local_Update	./apps/localAlg/Nibble-Parallel.C	/^struct Local_Update {$/;"	s	file:
MAXDEG_F	./apps/MaxDegree.C	/^    MAXDEG_F(vertex *_V):V(_V), maxdeg(0){}$/;"	f	struct:MAXDEG_F
MAXDEG_F	./apps/MaxDegree.C	/^struct MAXDEG_F {$/;"	s	file:
MAX_RADIX	./apps/blockRadixSort.h	48;"	d
MAX_RADIX	./ligra/blockRadixSort.h	48;"	d
MAX_RADIX	./tutorial/blockRadixSort.h	48;"	d
MAX_RADIX	./utils/blockRadixSort.h	48;"	d
MIS_Filter	./apps/MIS.C	/^  MIS_Filter(int* _flags) : flags(_flags) {}$/;"	f	struct:MIS_Filter
MIS_Filter	./apps/MIS.C	/^struct MIS_Filter {$/;"	s	file:
MIS_Update	./apps/MIS.C	/^  MIS_Update(int* _flags) : flags(_flags) {}$/;"	f	struct:MIS_Update
MIS_Update	./apps/MIS.C	/^struct MIS_Update {$/;"	s	file:
Neighbors	./utils/graphIO.h	/^  intT* Neighbors;$/;"	m	struct:vertex
Neighbors	./utils/graphIO.h	/^  intT* Neighbors;$/;"	m	struct:wghVertex
NextVisited	./apps/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_F	file:
NextVisited	./apps/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_Vertex_F	file:
NextVisited	./tutorial/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_F	file:
NextVisited	./tutorial/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_Vertex_F	file:
NextVisitedArray	./apps/eccentricity/FM-Ecc.C	/^  intE* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
NextVisitedArray	./apps/eccentricity/FM-Ecc.C	/^  intE* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
NextVisitedArray	./apps/eccentricity/LogLog-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
NextVisitedArray	./apps/eccentricity/LogLog-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
NextVisitedArray	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
NextVisitedArray	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
NextVisitedArray	./apps/eccentricity/kBFS-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
NextVisitedArray	./apps/eccentricity/kBFS-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
NextVisitedArray	./apps/eccentricity/kBFS-Exact.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
NextVisitedArray	./apps/eccentricity/kBFS-Exact.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
Nibble_F	./apps/localAlg/Nibble-Parallel.C	/^  Nibble_F(sparseAdditiveSet<float> &_p, sparseAdditiveSet<float> &_new_p, vertex* _V) : $/;"	f	struct:Nibble_F
Nibble_F	./apps/localAlg/Nibble-Parallel.C	/^struct Nibble_F {$/;"	s	file:
NumPaths	./apps/BC.C	/^  fType* NumPaths;$/;"	m	struct:BC_F	file:
OA	./apps/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
OA	./ligra/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
OA	./tutorial/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
OA	./utils/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
OB	./apps/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
OB	./ligra/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
OB	./tutorial/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
OB	./utils/transpose.h	/^  intT *OA, *OB, *L;$/;"	m	struct:blockTrans
ONE_BYTE	./apps/byteRLE-pd.h	298;"	d
ONE_BYTE	./apps/byteRLE.h	230;"	d
ONE_BYTE	./ligra/byteRLE-pd.h	298;"	d
ONE_BYTE	./ligra/byteRLE.h	230;"	d
ONE_BYTE	./tutorial/byteRLE-pd.h	298;"	d
ONE_BYTE	./tutorial/byteRLE.h	230;"	d
ONE_BYTE_SIGNED_MAX	./apps/byteRLE-pd.h	301;"	d
ONE_BYTE_SIGNED_MAX	./apps/byteRLE.h	233;"	d
ONE_BYTE_SIGNED_MAX	./ligra/byteRLE-pd.h	301;"	d
ONE_BYTE_SIGNED_MAX	./ligra/byteRLE.h	233;"	d
ONE_BYTE_SIGNED_MAX	./tutorial/byteRLE-pd.h	301;"	d
ONE_BYTE_SIGNED_MAX	./tutorial/byteRLE.h	233;"	d
ONE_BYTE_SIGNED_MIN	./apps/byteRLE-pd.h	302;"	d
ONE_BYTE_SIGNED_MIN	./apps/byteRLE.h	234;"	d
ONE_BYTE_SIGNED_MIN	./ligra/byteRLE-pd.h	302;"	d
ONE_BYTE_SIGNED_MIN	./ligra/byteRLE.h	234;"	d
ONE_BYTE_SIGNED_MIN	./tutorial/byteRLE-pd.h	302;"	d
ONE_BYTE_SIGNED_MIN	./tutorial/byteRLE.h	234;"	d
OUT	./apps/MIS.C	/^enum {UNDECIDED,CONDITIONALLY_IN,OUT,IN};$/;"	e	enum:__anon1	file:
PARALLEL	./apps/localAlg/Makefile	/^PARALLEL = ACL-Sync-Local ACL-Sync-Local-Opt HeatKernel-Parallel HeatKernel-Randomized-Parallel Nibble-Parallel$/;"	m
PARALLEL_DEGREE	./apps/byte-pd.h	36;"	d
PARALLEL_DEGREE	./apps/byteRLE-pd.h	39;"	d
PARALLEL_DEGREE	./apps/nibble-pd.h	39;"	d
PARALLEL_DEGREE	./ligra/byte-pd.h	36;"	d
PARALLEL_DEGREE	./ligra/byteRLE-pd.h	39;"	d
PARALLEL_DEGREE	./ligra/nibble-pd.h	39;"	d
PARALLEL_DEGREE	./tutorial/byte-pd.h	36;"	d
PARALLEL_DEGREE	./tutorial/byteRLE-pd.h	39;"	d
PARALLEL_DEGREE	./tutorial/nibble-pd.h	39;"	d
PCC	./apps/Makefile	/^PCC = g++$/;"	m
PCC	./apps/Makefile	/^PCC = icpc$/;"	m
PCC	./apps/eccentricity/Makefile	/^PCC = g++$/;"	m
PCC	./apps/eccentricity/Makefile	/^PCC = icpc$/;"	m
PCC	./apps/localAlg/Makefile	/^PCC = g++$/;"	m
PCC	./apps/localAlg/Makefile	/^PCC = icpc$/;"	m
PCC	./tutorial/Makefile	/^PCC = g++$/;"	m
PCC	./tutorial/Makefile	/^PCC = icpc$/;"	m
PCC	./utils/Makefile	/^PCC = g++$/;"	m
PCC	./utils/Makefile	/^PCC = icpc$/;"	m
PCFLAGS	./apps/Makefile	/^PCFLAGS = -O2 $(INTT) $(INTE) $(CODE) $(PD)$/;"	m
PCFLAGS	./apps/Makefile	/^PCFLAGS = -O3 -DCILKP $(INTT) $(INTE) $(CODE) $(PD)$/;"	m
PCFLAGS	./apps/Makefile	/^PCFLAGS = -fcilkplus -lcilkrts -O2 -DCILK $(INTT) $(INTE) $(CODE) $(PD)$/;"	m
PCFLAGS	./apps/Makefile	/^PCFLAGS = -fopenmp -O3 -DOPENMP $(INTT) $(INTE) $(CODE) $(PD)$/;"	m
PCFLAGS	./apps/eccentricity/Makefile	/^PCFLAGS = -O2 $(INTT) $(INTE)$/;"	m
PCFLAGS	./apps/eccentricity/Makefile	/^PCFLAGS = -O3 -DCILKP $(INTT) $(INTE)$/;"	m
PCFLAGS	./apps/eccentricity/Makefile	/^PCFLAGS = -fcilkplus -lcilkrts -O2 -DCILK $(INTT) $(INTE)$/;"	m
PCFLAGS	./apps/eccentricity/Makefile	/^PCFLAGS = -fopenmp -O3 -DOPENMP $(INTT) $(INTE)$/;"	m
PCFLAGS	./apps/localAlg/Makefile	/^PCFLAGS = -O3 -std=c++11 -DCILKP $(INTT) $(INTE)$/;"	m
PCFLAGS	./apps/localAlg/Makefile	/^PCFLAGS = -fcilkplus -lcilkrts -std=c++11 -O2 -DCILK $(INTT) $(INTE)$/;"	m
PCFLAGS	./apps/localAlg/Makefile	/^PCFLAGS = -fopenmp -O3 -std=c++11 -DOPENMP $(INTT) $(INTE)$/;"	m
PCFLAGS	./apps/localAlg/Makefile	/^PCFLAGS = -std=c++11 -O2 $(INTT) $(INTE)$/;"	m
PCFLAGS	./tutorial/Makefile	/^PCFLAGS = -O2 $(INTT) $(INTE)$/;"	m
PCFLAGS	./tutorial/Makefile	/^PCFLAGS = -O3 -DCILKP $(INTT) $(INTE)$/;"	m
PCFLAGS	./tutorial/Makefile	/^PCFLAGS = -fcilkplus -lcilkrts -O2 -DCILK $(INTT) $(INTE)$/;"	m
PCFLAGS	./tutorial/Makefile	/^PCFLAGS = -fopenmp -O3 -DOPENMP $(INTT) $(INTE)$/;"	m
PCFLAGS	./utils/Makefile	/^PCFLAGS = -O2 $(INTT) $(INTE)$/;"	m
PCFLAGS	./utils/Makefile	/^PCFLAGS = -O3 -DCILKP $(INTT) $(INTE)$/;"	m
PCFLAGS	./utils/Makefile	/^PCFLAGS = -fcilkplus -lcilkrts -O2 -DCILK $(INTT) $(INTE)$/;"	m
PCFLAGS	./utils/Makefile	/^PCFLAGS = -fopenmp -O3 -DOPENMP $(INTT) $(INTE)$/;"	m
PD	./apps/Makefile	/^PD = -DPD$/;"	m
PIVOT_QUOT	./apps/localAlg/sampleSort.h	54;"	d
PLFLAGS	./apps/Makefile	/^PLFLAGS = -fcilkplus -lcilkrts$/;"	m
PLFLAGS	./apps/eccentricity/Makefile	/^PLFLAGS = -fcilkplus -lcilkrts$/;"	m
PLFLAGS	./apps/localAlg/Makefile	/^PLFLAGS = -fcilkplus -lcilkrts$/;"	m
PLFLAGS	./tutorial/Makefile	/^PLFLAGS = -fcilkplus -lcilkrts$/;"	m
PLFLAGS	./utils/Makefile	/^PLFLAGS = -fcilkplus -lcilkrts$/;"	m
PR_F	./apps/PageRank.C	/^  PR_F(double* _p_curr, double* _p_next, vertex* _V) : $/;"	f	struct:PR_F
PR_F	./apps/PageRank.C	/^struct PR_F {$/;"	s	file:
PR_F	./apps/PageRankDelta.C	/^  PR_F(vertex* _V, double* _Delta, double* _nghSum) : $/;"	f	struct:PR_F
PR_F	./apps/PageRankDelta.C	/^struct PR_F {$/;"	s	file:
PR_Vertex_F	./apps/PageRank.C	/^  PR_Vertex_F(double* _p_curr, double* _p_next, double _damping, intE n) :$/;"	f	struct:PR_Vertex_F
PR_Vertex_F	./apps/PageRank.C	/^struct PR_Vertex_F {$/;"	s	file:
PR_Vertex_F	./apps/PageRankDelta.C	/^  PR_Vertex_F(double* _p, double* _Delta, double* _nghSum, double _damping, double _epsilon2) :$/;"	f	struct:PR_Vertex_F
PR_Vertex_F	./apps/PageRankDelta.C	/^struct PR_Vertex_F {$/;"	s	file:
PR_Vertex_F_FirstRound	./apps/PageRankDelta.C	/^  PR_Vertex_F_FirstRound(double* _p, double* _Delta, double* _nghSum, double _damping, double _one_over_n,double _epsilon2) :$/;"	f	struct:PR_Vertex_F_FirstRound
PR_Vertex_F_FirstRound	./apps/PageRankDelta.C	/^struct PR_Vertex_F_FirstRound {$/;"	s	file:
PR_Vertex_Reset	./apps/PageRank.C	/^  PR_Vertex_Reset(double* _p_curr) :$/;"	f	struct:PR_Vertex_Reset
PR_Vertex_Reset	./apps/PageRank.C	/^struct PR_Vertex_Reset {$/;"	s	file:
PR_Vertex_Reset	./apps/PageRankDelta.C	/^  PR_Vertex_Reset(double* _nghSum) :$/;"	f	struct:PR_Vertex_Reset
PR_Vertex_Reset	./apps/PageRankDelta.C	/^struct PR_Vertex_Reset {$/;"	s	file:
Parents	./apps/BFS-Bitvector.C	/^  uintE* Parents; long* Visited;$/;"	m	struct:BFS_F	file:
Parents	./apps/BFS.C	/^  uintE* Parents;$/;"	m	struct:BFS_F	file:
Parents	./apps/BFSCC.C	/^  uintE* Parents;$/;"	m	struct:BFS_F	file:
Parents	./apps/MaxDegree.C	/^  uintE* Parents;$/;"	m	struct:BFS_F	file:
Parents	./tutorial/BFS.C	/^  long* Parents;$/;"	m	struct:BFS_F	file:
Radii_F	./apps/Radii.C	/^  Radii_F(long* _Visited, long* _NextVisited, intE* _radii, intE _round) : $/;"	f	struct:Radii_F
Radii_F	./apps/Radii.C	/^struct Radii_F {$/;"	s	file:
Radii_F	./tutorial/Radii.C	/^  Radii_F(long* _Visited, long* _NextVisited, long* _radii, long _round) : $/;"	f	struct:Radii_F
Radii_F	./tutorial/Radii.C	/^struct Radii_F {$/;"	s	file:
Radii_Vertex_F	./apps/Radii.C	/^  Radii_Vertex_F(long* _Visited, long* _NextVisited) :$/;"	f	struct:Radii_Vertex_F
Radii_Vertex_F	./apps/Radii.C	/^struct Radii_Vertex_F {$/;"	s	file:
Radii_Vertex_F	./tutorial/Radii.C	/^  Radii_Vertex_F(long* _Visited, long* _NextVisited) :$/;"	f	struct:Radii_Vertex_F
Radii_Vertex_F	./tutorial/Radii.C	/^struct Radii_Vertex_F {$/;"	s	file:
SAMPLE_SORT_H	./apps/localAlg/sampleSort.h	23;"	d
SERIAL	./apps/localAlg/Makefile	/^SERIAL = ACL-Serial ACL-Serial-Naive ACL-Serial-Opt ACL-Serial-Opt-Naive HeatKernel-Serial HeatKernel-Randomized-Serial Nibble-Serial$/;"	m
SSORT_THR	./apps/localAlg/sampleSort.h	52;"	d
S_HASH_INCLUDED	./apps/localAlg/sparseSet.h	25;"	d
ShortestPathLen	./apps/BellmanFord.C	/^  intE* ShortestPathLen;$/;"	m	struct:BF_F	file:
ShortestPathLen	./tutorial/BellmanFord.C	/^  long* ShortestPathLen;$/;"	m	struct:BF_F	file:
Strings	./apps/IO.h	/^  char** Strings; \/\/ pointers to strings (all should be null terminated)$/;"	m	struct:words
Strings	./ligra/IO.h	/^  char** Strings; \/\/ pointers to strings (all should be null terminated)$/;"	m	struct:words
Strings	./tutorial/IO.h	/^  char** Strings; \/\/ pointers to strings (all should be null terminated)$/;"	m	struct:words
Strings	./utils/graphIO.h	/^    char** Strings; \/\/ pointers to strings (all should be null terminated)$/;"	m	struct:benchIO::words
TA	./apps/localAlg/sparseSet.h	/^  kvPair* TA;$/;"	m	class:sparseAdditiveSet
THREE_BYTES	./apps/byteRLE-pd.h	300;"	d
THREE_BYTES	./apps/byteRLE.h	232;"	d
THREE_BYTES	./ligra/byteRLE-pd.h	300;"	d
THREE_BYTES	./ligra/byteRLE.h	232;"	d
THREE_BYTES	./tutorial/byteRLE-pd.h	300;"	d
THREE_BYTES	./tutorial/byteRLE.h	232;"	d
THREE_BYTES_SIGNED_MAX	./apps/byteRLE-pd.h	305;"	d
THREE_BYTES_SIGNED_MAX	./apps/byteRLE.h	237;"	d
THREE_BYTES_SIGNED_MAX	./ligra/byteRLE-pd.h	305;"	d
THREE_BYTES_SIGNED_MAX	./ligra/byteRLE.h	237;"	d
THREE_BYTES_SIGNED_MAX	./tutorial/byteRLE-pd.h	305;"	d
THREE_BYTES_SIGNED_MAX	./tutorial/byteRLE.h	237;"	d
THREE_BYTES_SIGNED_MIN	./apps/byteRLE-pd.h	306;"	d
THREE_BYTES_SIGNED_MIN	./apps/byteRLE.h	238;"	d
THREE_BYTES_SIGNED_MIN	./ligra/byteRLE-pd.h	306;"	d
THREE_BYTES_SIGNED_MIN	./ligra/byteRLE.h	238;"	d
THREE_BYTES_SIGNED_MIN	./tutorial/byteRLE-pd.h	306;"	d
THREE_BYTES_SIGNED_MIN	./tutorial/byteRLE.h	238;"	d
TWO_BYTES	./apps/byteRLE-pd.h	299;"	d
TWO_BYTES	./apps/byteRLE.h	231;"	d
TWO_BYTES	./ligra/byteRLE-pd.h	299;"	d
TWO_BYTES	./ligra/byteRLE.h	231;"	d
TWO_BYTES	./tutorial/byteRLE-pd.h	299;"	d
TWO_BYTES	./tutorial/byteRLE.h	231;"	d
TWO_BYTES_SIGNED_MAX	./apps/byteRLE-pd.h	303;"	d
TWO_BYTES_SIGNED_MAX	./apps/byteRLE.h	235;"	d
TWO_BYTES_SIGNED_MAX	./ligra/byteRLE-pd.h	303;"	d
TWO_BYTES_SIGNED_MAX	./ligra/byteRLE.h	235;"	d
TWO_BYTES_SIGNED_MAX	./tutorial/byteRLE-pd.h	303;"	d
TWO_BYTES_SIGNED_MAX	./tutorial/byteRLE.h	235;"	d
TWO_BYTES_SIGNED_MIN	./apps/byteRLE-pd.h	304;"	d
TWO_BYTES_SIGNED_MIN	./apps/byteRLE.h	236;"	d
TWO_BYTES_SIGNED_MIN	./ligra/byteRLE-pd.h	304;"	d
TWO_BYTES_SIGNED_MIN	./ligra/byteRLE.h	236;"	d
TWO_BYTES_SIGNED_MIN	./tutorial/byteRLE-pd.h	304;"	d
TWO_BYTES_SIGNED_MIN	./tutorial/byteRLE.h	236;"	d
UINT_E_MAX	./apps/parallel.h	119;"	d
UINT_E_MAX	./apps/parallel.h	124;"	d
UINT_E_MAX	./ligra/parallel.h	119;"	d
UINT_E_MAX	./ligra/parallel.h	124;"	d
UINT_E_MAX	./tutorial/parallel.h	119;"	d
UINT_E_MAX	./tutorial/parallel.h	124;"	d
UINT_E_MAX	./utils/parallel.h	119;"	d
UINT_E_MAX	./utils/parallel.h	124;"	d
UINT_T_MAX	./apps/parallel.h	106;"	d
UINT_T_MAX	./apps/parallel.h	111;"	d
UINT_T_MAX	./ligra/parallel.h	106;"	d
UINT_T_MAX	./ligra/parallel.h	111;"	d
UINT_T_MAX	./tutorial/parallel.h	106;"	d
UINT_T_MAX	./tutorial/parallel.h	111;"	d
UINT_T_MAX	./utils/parallel.h	106;"	d
UINT_T_MAX	./utils/parallel.h	111;"	d
UNDECIDED	./apps/MIS.C	/^enum {UNDECIDED,CONDITIONALLY_IN,OUT,IN};$/;"	e	enum:__anon1	file:
UTIL_H	./apps/utils.h	25;"	d
UTIL_H	./ligra/utils.h	25;"	d
UTIL_H	./tutorial/utils.h	25;"	d
UTIL_H	./utils/utils.h	25;"	d
Uncompressed_Mem	./apps/IO.h	/^  Uncompressed_Mem(vertex* VV, long nn, long mm, void* ai, void* _inEdges = NULL) $/;"	f	struct:Uncompressed_Mem
Uncompressed_Mem	./apps/IO.h	/^struct Uncompressed_Mem : public Deletable {$/;"	s
Uncompressed_Mem	./ligra/IO.h	/^  Uncompressed_Mem(vertex* VV, long nn, long mm, void* ai, void* _inEdges = NULL) $/;"	f	struct:Uncompressed_Mem
Uncompressed_Mem	./ligra/IO.h	/^struct Uncompressed_Mem : public Deletable {$/;"	s
Uncompressed_Mem	./tutorial/IO.h	/^  Uncompressed_Mem(vertex* VV, long nn, long mm, void* ai, void* _inEdges = NULL) $/;"	f	struct:Uncompressed_Mem
Uncompressed_Mem	./tutorial/IO.h	/^struct Uncompressed_Mem : public Deletable {$/;"	s
Update_Deg	./apps/KCore.C	/^  Update_Deg(intE* _Degrees) : Degrees(_Degrees) {}$/;"	f	struct:Update_Deg
Update_Deg	./apps/KCore.C	/^struct Update_Deg {$/;"	s	file:
Update_Deg	./tutorial/KCore.C	/^  Update_Deg(long* _Degrees) : Degrees(_Degrees) {}$/;"	f	struct:Update_Deg
Update_Deg	./tutorial/KCore.C	/^struct Update_Deg {$/;"	s	file:
V	./apps/CF.C	/^  vertex* V;$/;"	m	struct:CF_Edge_F	file:
V	./apps/IO.h	/^  vertex* V;$/;"	m	struct:Compressed_Mem
V	./apps/IO.h	/^  vertex* V;$/;"	m	struct:Uncompressed_Mem
V	./apps/KCore.C	/^  vertex* V;$/;"	m	struct:Deg_AtLeast_K	file:
V	./apps/KCore.C	/^  vertex* V;$/;"	m	struct:Deg_LessThan_K	file:
V	./apps/MaxDegree.C	/^    vertex *V;$/;"	m	struct:MAXDEG_F	file:
V	./apps/PageRank.C	/^  vertex* V;$/;"	m	struct:PR_F	file:
V	./apps/PageRankDelta.C	/^  vertex* V;$/;"	m	struct:PR_F	file:
V	./apps/Triangle.C	/^  vertex* V;$/;"	m	struct:countF	file:
V	./apps/Triangle.C	/^  vertex* V;$/;"	m	struct:initF	file:
V	./apps/eccentricity/CLRSTV.C	/^  vertex* V;$/;"	m	struct:getDegree	file:
V	./apps/eccentricity/RV.C	/^  vertex* V;$/;"	m	struct:getDegree	file:
V	./apps/eccentricity/Simple-Approx-Ecc.C	/^  vertex* V;$/;"	m	struct:getDegree	file:
V	./apps/eccentricity/TK.C	/^  vertex* V;$/;"	m	struct:getDegree	file:
V	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  vertex* V;$/;"	m	struct:getDegree	file:
V	./apps/eccentricity/kBFS-Ecc.C	/^  vertex* V;$/;"	m	struct:getDegree	file:
V	./apps/graph.h	/^  vertex *V;$/;"	m	struct:graph
V	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  vertex* V;$/;"	m	struct:ACL_F	file:
V	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  vertex* V;$/;"	m	struct:activeF	file:
V	./apps/localAlg/ACL-Sync-Local.C	/^  vertex* V;$/;"	m	struct:ACL_F	file:
V	./apps/localAlg/ACL-Sync-Local.C	/^  vertex* V;$/;"	m	struct:activeF	file:
V	./apps/localAlg/HeatKernel-Parallel.C	/^  vertex* V;$/;"	m	struct:HK_F	file:
V	./apps/localAlg/HeatKernel-Parallel.C	/^  vertex* V;$/;"	m	struct:HK_Last_F	file:
V	./apps/localAlg/HeatKernel-Parallel.C	/^  vertex* V;$/;"	m	struct:activeF	file:
V	./apps/localAlg/Nibble-Parallel.C	/^  vertex* V;$/;"	m	struct:Nibble_F	file:
V	./apps/localAlg/Nibble-Parallel.C	/^  vertex* V;$/;"	m	struct:activeF	file:
V	./apps/localAlg/sweep.h	/^  vertex* V;$/;"	m	struct:sweep_compare
V	./ligra/IO.h	/^  vertex* V;$/;"	m	struct:Compressed_Mem
V	./ligra/IO.h	/^  vertex* V;$/;"	m	struct:Uncompressed_Mem
V	./ligra/graph.h	/^  vertex *V;$/;"	m	struct:graph
V	./tutorial/IO.h	/^  vertex* V;$/;"	m	struct:Compressed_Mem
V	./tutorial/IO.h	/^  vertex* V;$/;"	m	struct:Uncompressed_Mem
V	./tutorial/KCore.C	/^  vertex* V;$/;"	m	struct:Deg_AtLeast_K	file:
V	./tutorial/KCore.C	/^  vertex* V;$/;"	m	struct:Deg_LessThan_K	file:
V	./tutorial/graph.h	/^  vertex *V;$/;"	m	struct:graph
V	./utils/graphIO.h	/^  vertex<intT> *V;$/;"	m	struct:graph
V	./utils/graphIO.h	/^  wghVertex<intT> *V;$/;"	m	struct:wghGraph
VERTEX_H	./apps/vertex.h	2;"	d
VERTEX_H	./ligra/vertex.h	2;"	d
VERTEX_H	./tutorial/vertex.h	2;"	d
VERTEX_SUBSET_H	./apps/vertexSubset.h	2;"	d
VERTEX_SUBSET_H	./ligra/vertexSubset.h	2;"	d
VERTEX_SUBSET_H	./tutorial/vertexSubset.h	2;"	d
Visited	./apps/BC.C	/^  bool* Visited;$/;"	m	struct:BC_Back_F	file:
Visited	./apps/BC.C	/^  bool* Visited;$/;"	m	struct:BC_Back_Vertex_F	file:
Visited	./apps/BC.C	/^  bool* Visited;$/;"	m	struct:BC_F	file:
Visited	./apps/BC.C	/^  bool* Visited;$/;"	m	struct:BC_Vertex_F	file:
Visited	./apps/BFS-Bitvector.C	/^  uintE* Parents; long* Visited;$/;"	m	struct:BFS_F	file:
Visited	./apps/BellmanFord.C	/^  int* Visited;$/;"	m	struct:BF_F	file:
Visited	./apps/BellmanFord.C	/^  int* Visited;$/;"	m	struct:BF_Vertex_F	file:
Visited	./apps/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_F	file:
Visited	./apps/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_Vertex_F	file:
Visited	./tutorial/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_F	file:
Visited	./tutorial/Radii.C	/^  long* Visited, *NextVisited;$/;"	m	struct:Radii_Vertex_F	file:
VisitedArray	./apps/eccentricity/FM-Ecc.C	/^  intE* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
VisitedArray	./apps/eccentricity/FM-Ecc.C	/^  intE* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
VisitedArray	./apps/eccentricity/LogLog-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
VisitedArray	./apps/eccentricity/LogLog-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
VisitedArray	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
VisitedArray	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
VisitedArray	./apps/eccentricity/kBFS-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
VisitedArray	./apps/eccentricity/kBFS-Ecc.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
VisitedArray	./apps/eccentricity/kBFS-Exact.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_F	file:
VisitedArray	./apps/eccentricity/kBFS-Exact.C	/^  long* VisitedArray, *NextVisitedArray;$/;"	m	struct:Ecc_Vertex_F	file:
WEIGHTED	./apps/BellmanFord.C	24;"	d	file:
WEIGHTED	./apps/CF.C	20;"	d	file:
WEIGHTED	./tutorial/BellmanFord.C	1;"	d	file:
WghAdjGraphHeader	./utils/graphIO.h	/^  string WghAdjGraphHeader = "WeightedAdjacencyGraph";$/;"	m	namespace:benchIO
_BENCH_GETTIME_INCLUDED	./apps/gettime.h	23;"	d
_BENCH_GETTIME_INCLUDED	./ligra/gettime.h	23;"	d
_BENCH_GETTIME_INCLUDED	./tutorial/gettime.h	23;"	d
_BENCH_GRAPH_IO	./utils/graphIO.h	23;"	d
_F_BSIZE	./apps/utils.h	222;"	d
_F_BSIZE	./ligra/utils.h	222;"	d
_F_BSIZE	./tutorial/utils.h	222;"	d
_F_BSIZE	./utils/utils.h	222;"	d
_PARALLEL_H	./apps/parallel.h	25;"	d
_PARALLEL_H	./ligra/parallel.h	25;"	d
_PARALLEL_H	./tutorial/parallel.h	25;"	d
_PARALLEL_H	./utils/parallel.h	25;"	d
_PARSE_COMMAND_LINE	./apps/parseCommandLine.h	24;"	d
_PARSE_COMMAND_LINE	./ligra/parseCommandLine.h	24;"	d
_PARSE_COMMAND_LINE	./tutorial/parseCommandLine.h	24;"	d
_PARSE_COMMAND_LINE	./utils/parseCommandLine.h	24;"	d
_SCAN_BSIZE	./apps/utils.h	67;"	d
_SCAN_BSIZE	./ligra/utils.h	67;"	d
_SCAN_BSIZE	./tutorial/utils.h	67;"	d
_SCAN_BSIZE	./utils/utils.h	67;"	d
_SCAN_LOG_BSIZE	./apps/utils.h	66;"	d
_SCAN_LOG_BSIZE	./ligra/utils.h	66;"	d
_SCAN_LOG_BSIZE	./tutorial/utils.h	66;"	d
_SCAN_LOG_BSIZE	./utils/utils.h	66;"	d
_TRANS_THRESHHOLD	./apps/transpose.h	28;"	d
_TRANS_THRESHHOLD	./ligra/transpose.h	28;"	d
_TRANS_THRESHHOLD	./tutorial/transpose.h	28;"	d
_TRANS_THRESHHOLD	./utils/transpose.h	28;"	d
__ii	./apps/utils.h	/^static int __ii =  mallopt(M_MMAP_MAX,0);$/;"	v
__ii	./ligra/utils.h	/^static int __ii =  mallopt(M_MMAP_MAX,0);$/;"	v
__ii	./tutorial/utils.h	/^static int __ii =  mallopt(M_MMAP_MAX,0);$/;"	v
__ii	./utils/utils.h	/^static int __ii =  mallopt(M_MMAP_MAX,0);$/;"	v
__jj	./apps/utils.h	/^static int __jj =  mallopt(M_TRIM_THRESHOLD,-1); $/;"	v
__jj	./ligra/utils.h	/^static int __jj =  mallopt(M_TRIM_THRESHOLD,-1); $/;"	v
__jj	./tutorial/utils.h	/^static int __jj =  mallopt(M_TRIM_THRESHOLD,-1); $/;"	v
__jj	./utils/utils.h	/^static int __jj =  mallopt(M_TRIM_THRESHOLD,-1); $/;"	v
_f	./apps/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_f	./ligra/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_f	./tutorial/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_f	./utils/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_mask	./apps/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_mask	./ligra/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_mask	./tutorial/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_mask	./utils/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_offset	./apps/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_offset	./ligra/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_offset	./tutorial/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_offset	./utils/blockRadixSort.h	/^      F _f;  long _mask;  long _offset;$/;"	m	struct:intSort::eBits
_seq	./apps/utils.h	/^  _seq() {A = NULL; n=0;}$/;"	f	struct:_seq
_seq	./apps/utils.h	/^_seq(T* _A, long _n) : A(_A), n(_n) {}$/;"	f	struct:_seq
_seq	./apps/utils.h	/^struct _seq {$/;"	s
_seq	./ligra/utils.h	/^  _seq() {A = NULL; n=0;}$/;"	f	struct:_seq
_seq	./ligra/utils.h	/^_seq(T* _A, long _n) : A(_A), n(_n) {}$/;"	f	struct:_seq
_seq	./ligra/utils.h	/^struct _seq {$/;"	s
_seq	./tutorial/utils.h	/^  _seq() {A = NULL; n=0;}$/;"	f	struct:_seq
_seq	./tutorial/utils.h	/^_seq(T* _A, long _n) : A(_A), n(_n) {}$/;"	f	struct:_seq
_seq	./tutorial/utils.h	/^struct _seq {$/;"	s
_seq	./utils/utils.h	/^  _seq() {A = NULL; n=0;}$/;"	f	struct:_seq
_seq	./utils/utils.h	/^_seq(T* _A, long _n) : A(_A), n(_n) {}$/;"	f	struct:_seq
_seq	./utils/utils.h	/^struct _seq {$/;"	s
_tm	./apps/gettime.h	/^static timer _tm;$/;"	v
_tm	./ligra/gettime.h	/^static timer _tm;$/;"	v
_tm	./tutorial/gettime.h	/^static timer _tm;$/;"	v
a	./utils/rMatGraph.C	/^  double a, ab, abc;$/;"	m	struct:rMat	file:
ab	./utils/rMatGraph.C	/^  double a, ab, abc;$/;"	m	struct:rMat	file:
abc	./utils/rMatGraph.C	/^  double a, ab, abc;$/;"	m	struct:rMat	file:
activeF	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  activeF(vertex* _V, double _epsilon) :$/;"	f	struct:activeF
activeF	./apps/localAlg/ACL-Sync-Local-Opt.C	/^struct activeF {$/;"	s	file:
activeF	./apps/localAlg/ACL-Sync-Local.C	/^  activeF(vertex* _V, double _epsilon) :$/;"	f	struct:activeF
activeF	./apps/localAlg/ACL-Sync-Local.C	/^struct activeF {$/;"	s	file:
activeF	./apps/localAlg/HeatKernel-Parallel.C	/^  activeF(vertex* _V, double _constantOverPsi) :$/;"	f	struct:activeF
activeF	./apps/localAlg/HeatKernel-Parallel.C	/^struct activeF {$/;"	s	file:
activeF	./apps/localAlg/Nibble-Parallel.C	/^  activeF(vertex* _V, double _epsilon) :$/;"	f	struct:activeF
activeF	./apps/localAlg/Nibble-Parallel.C	/^struct activeF {$/;"	s	file:
addF	./apps/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	s
addF	./ligra/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	s
addF	./tutorial/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	s
addF	./utils/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	s
addFirst	./apps/localAlg/sweep.h	/^struct addFirst { pairIntT operator() (pairIntT a, pairIntT b){$/;"	s
addedConstant	./apps/PageRank.C	/^  double addedConstant;$/;"	m	struct:PR_Vertex_F	file:
addedConstant	./apps/PageRankDelta.C	/^  double damping, addedConstant, one_over_n, epsilon2;$/;"	m	struct:PR_Vertex_F_FirstRound	file:
allocatedInplace	./apps/IO.h	/^  void* allocatedInplace, * inEdges;$/;"	m	struct:Uncompressed_Mem
allocatedInplace	./ligra/IO.h	/^  void* allocatedInplace, * inEdges;$/;"	m	struct:Uncompressed_Mem
allocatedInplace	./tutorial/IO.h	/^  void* allocatedInplace, * inEdges;$/;"	m	struct:Uncompressed_Mem
allocatedInplace	./utils/graphIO.h	/^  intT* allocatedInplace;$/;"	m	struct:graph
allocatedInplace	./utils/graphIO.h	/^  intT* allocatedInplace;$/;"	m	struct:wghGraph
alpha	./apps/localAlg/ACL-Sync-Local.C	/^  double alpha, toSubtract;$/;"	m	struct:Local_Update	file:
argc	./apps/parseCommandLine.h	/^  int argc;$/;"	m	struct:commandLine
argc	./ligra/parseCommandLine.h	/^  int argc;$/;"	m	struct:commandLine
argc	./tutorial/parseCommandLine.h	/^  int argc;$/;"	m	struct:commandLine
argc	./utils/parseCommandLine.h	/^  int argc;$/;"	m	struct:commandLine
argv	./apps/parseCommandLine.h	/^  char** argv;$/;"	m	struct:commandLine
argv	./ligra/parseCommandLine.h	/^  char** argv;$/;"	m	struct:commandLine
argv	./tutorial/parseCommandLine.h	/^  char** argv;$/;"	m	struct:commandLine
argv	./utils/parseCommandLine.h	/^  char** argv;$/;"	m	struct:commandLine
arrayToString	./utils/graphIO.h	/^  _seq<char> arrayToString(T* A, long n) {$/;"	f	namespace:benchIO
asymmetricVertex	./apps/vertex.h	/^asymmetricVertex(uintE* iN, uintE* oN, uintT id, uintT od) $/;"	f	struct:asymmetricVertex
asymmetricVertex	./apps/vertex.h	/^struct asymmetricVertex {$/;"	s
asymmetricVertex	./ligra/vertex.h	/^asymmetricVertex(uintE* iN, uintE* oN, uintT id, uintT od) $/;"	f	struct:asymmetricVertex
asymmetricVertex	./ligra/vertex.h	/^struct asymmetricVertex {$/;"	s
asymmetricVertex	./tutorial/vertex.h	/^asymmetricVertex(uintE* iN, uintE* oN, uintT id, uintT od) $/;"	f	struct:asymmetricVertex
asymmetricVertex	./tutorial/vertex.h	/^struct asymmetricVertex {$/;"	s
bIndexT	./apps/blockRadixSort.h	/^  typedef unsigned char bIndexT;$/;"	t	namespace:intSort
bIndexT	./ligra/blockRadixSort.h	/^  typedef unsigned char bIndexT;$/;"	t	namespace:intSort
bIndexT	./tutorial/blockRadixSort.h	/^  typedef unsigned char bIndexT;$/;"	t	namespace:intSort
bIndexT	./utils/blockRadixSort.h	/^  typedef unsigned char bIndexT;$/;"	t	namespace:intSort
badArgument	./apps/parseCommandLine.h	/^  void badArgument() {$/;"	f	struct:commandLine
badArgument	./ligra/parseCommandLine.h	/^  void badArgument() {$/;"	f	struct:commandLine
badArgument	./tutorial/parseCommandLine.h	/^  void badArgument() {$/;"	f	struct:commandLine
badArgument	./utils/parseCommandLine.h	/^  void badArgument() {$/;"	f	struct:commandLine
benchIO	./utils/graphIO.h	/^namespace benchIO {$/;"	n
bestGlobalCond	./apps/localAlg/sweep.h	/^static double bestGlobalCond = DBL_MAX;$/;"	v
bestSize	./apps/localAlg/sweep.h	/^static long bestSize = -1;$/;"	v
bestStart	./apps/localAlg/sweep.h	/^static long bestStart = -1;$/;"	v
blockTrans	./apps/transpose.h	/^  blockTrans(E *AA, E *BB, intT *OOA, intT *OOB, intT *LL) $/;"	f	struct:blockTrans
blockTrans	./apps/transpose.h	/^struct blockTrans {$/;"	s
blockTrans	./ligra/transpose.h	/^  blockTrans(E *AA, E *BB, intT *OOA, intT *OOB, intT *LL) $/;"	f	struct:blockTrans
blockTrans	./ligra/transpose.h	/^struct blockTrans {$/;"	s
blockTrans	./tutorial/transpose.h	/^  blockTrans(E *AA, E *BB, intT *OOA, intT *OOB, intT *LL) $/;"	f	struct:blockTrans
blockTrans	./tutorial/transpose.h	/^struct blockTrans {$/;"	s
blockTrans	./utils/transpose.h	/^  blockTrans(E *AA, E *BB, intT *OOA, intT *OOB, intT *LL) $/;"	f	struct:blockTrans
blockTrans	./utils/transpose.h	/^struct blockTrans {$/;"	s
blocked_for	./apps/utils.h	103;"	d
blocked_for	./ligra/utils.h	103;"	d
blocked_for	./tutorial/utils.h	103;"	d
blocked_for	./utils/utils.h	103;"	d
boolGetA	./apps/utils.h	/^    boolGetA(bool* AA) : A(AA) {}$/;"	f	struct:sequence::boolGetA
boolGetA	./apps/utils.h	/^  struct boolGetA {$/;"	s	namespace:sequence
boolGetA	./ligra/utils.h	/^    boolGetA(bool* AA) : A(AA) {}$/;"	f	struct:sequence::boolGetA
boolGetA	./ligra/utils.h	/^  struct boolGetA {$/;"	s	namespace:sequence
boolGetA	./tutorial/utils.h	/^    boolGetA(bool* AA) : A(AA) {}$/;"	f	struct:sequence::boolGetA
boolGetA	./tutorial/utils.h	/^  struct boolGetA {$/;"	s	namespace:sequence
boolGetA	./utils/utils.h	/^    boolGetA(bool* AA) : A(AA) {}$/;"	f	struct:sequence::boolGetA
boolGetA	./utils/utils.h	/^  struct boolGetA {$/;"	s	namespace:sequence
broadwordMax	./apps/eccentricity/LogLog-Ecc.C	43;"	d	file:
checkMis	./apps/MIS.C	/^bool checkMis(graph<vertex>& G, int* flags) {$/;"	f
cilk_for	./apps/parallel.h	94;"	d
cilk_for	./ligra/parallel.h	94;"	d
cilk_for	./tutorial/parallel.h	94;"	d
cilk_for	./utils/parallel.h	94;"	d
cilk_spawn	./apps/parallel.h	77;"	d
cilk_spawn	./apps/parallel.h	88;"	d
cilk_spawn	./ligra/parallel.h	77;"	d
cilk_spawn	./ligra/parallel.h	88;"	d
cilk_spawn	./tutorial/parallel.h	77;"	d
cilk_spawn	./tutorial/parallel.h	88;"	d
cilk_spawn	./utils/parallel.h	77;"	d
cilk_spawn	./utils/parallel.h	88;"	d
cilk_sync	./apps/parallel.h	78;"	d
cilk_sync	./apps/parallel.h	89;"	d
cilk_sync	./ligra/parallel.h	78;"	d
cilk_sync	./ligra/parallel.h	89;"	d
cilk_sync	./tutorial/parallel.h	78;"	d
cilk_sync	./tutorial/parallel.h	89;"	d
cilk_sync	./utils/parallel.h	78;"	d
cilk_sync	./utils/parallel.h	89;"	d
clearA	./apps/localAlg/sparseSet.h	/^  static void clearA(kvPair* A, long n, kvPair v) {$/;"	f	class:sparseAdditiveSet
comLine	./apps/parseCommandLine.h	/^  string comLine;$/;"	m	struct:commandLine
comLine	./ligra/parseCommandLine.h	/^  string comLine;$/;"	m	struct:commandLine
comLine	./tutorial/parseCommandLine.h	/^  string comLine;$/;"	m	struct:commandLine
comLine	./utils/parseCommandLine.h	/^  string comLine;$/;"	m	struct:commandLine
commandLine	./apps/parseCommandLine.h	/^  commandLine(int _c, char** _v) $/;"	f	struct:commandLine
commandLine	./apps/parseCommandLine.h	/^  commandLine(int _c, char** _v, string _cl) $/;"	f	struct:commandLine
commandLine	./apps/parseCommandLine.h	/^struct commandLine {$/;"	s
commandLine	./ligra/parseCommandLine.h	/^  commandLine(int _c, char** _v) $/;"	f	struct:commandLine
commandLine	./ligra/parseCommandLine.h	/^  commandLine(int _c, char** _v, string _cl) $/;"	f	struct:commandLine
commandLine	./ligra/parseCommandLine.h	/^struct commandLine {$/;"	s
commandLine	./tutorial/parseCommandLine.h	/^  commandLine(int _c, char** _v) $/;"	f	struct:commandLine
commandLine	./tutorial/parseCommandLine.h	/^  commandLine(int _c, char** _v, string _cl) $/;"	f	struct:commandLine
commandLine	./tutorial/parseCommandLine.h	/^struct commandLine {$/;"	s
commandLine	./utils/parseCommandLine.h	/^  commandLine(int _c, char** _v) $/;"	f	struct:commandLine
commandLine	./utils/parseCommandLine.h	/^  commandLine(int _c, char** _v, string _cl) $/;"	f	struct:commandLine
commandLine	./utils/parseCommandLine.h	/^struct commandLine {$/;"	s
compressEdge	./apps/byte-pd.h	/^long compressEdge(uchar *start, long curOffset, uintE e) {$/;"	f
compressEdge	./apps/byte.h	/^long compressEdge(uchar *start, long curOffset, uintE e) {$/;"	f
compressEdge	./ligra/byte-pd.h	/^long compressEdge(uchar *start, long curOffset, uintE e) {$/;"	f
compressEdge	./ligra/byte.h	/^long compressEdge(uchar *start, long curOffset, uintE e) {$/;"	f
compressEdge	./tutorial/byte-pd.h	/^long compressEdge(uchar *start, long curOffset, uintE e) {$/;"	f
compressEdge	./tutorial/byte.h	/^long compressEdge(uchar *start, long curOffset, uintE e) {$/;"	f
compressEdges	./apps/byteRLE-pd.h	/^long compressEdges(uchar *start, long curOffset, uintE* savedEdges, uintE edgeI, int numBytes, uintT runlength) {$/;"	f
compressEdges	./apps/byteRLE.h	/^long compressEdges(uchar *start, long curOffset, uintE* savedEdges, uintE edgeI, int numBytes, uintT runlength) {$/;"	f
compressEdges	./ligra/byteRLE-pd.h	/^long compressEdges(uchar *start, long curOffset, uintE* savedEdges, uintE edgeI, int numBytes, uintT runlength) {$/;"	f
compressEdges	./ligra/byteRLE.h	/^long compressEdges(uchar *start, long curOffset, uintE* savedEdges, uintE edgeI, int numBytes, uintT runlength) {$/;"	f
compressEdges	./tutorial/byteRLE-pd.h	/^long compressEdges(uchar *start, long curOffset, uintE* savedEdges, uintE edgeI, int numBytes, uintT runlength) {$/;"	f
compressEdges	./tutorial/byteRLE.h	/^long compressEdges(uchar *start, long curOffset, uintE* savedEdges, uintE edgeI, int numBytes, uintT runlength) {$/;"	f
compressFirstEdge	./apps/byte-pd.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./apps/byte.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./apps/byteRLE-pd.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./apps/byteRLE.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./ligra/byte-pd.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./ligra/byte.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./ligra/byteRLE-pd.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./ligra/byteRLE.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./tutorial/byte-pd.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./tutorial/byte.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./tutorial/byteRLE-pd.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressFirstEdge	./tutorial/byteRLE.h	/^long compressFirstEdge(uchar *start, long offset, uintE source, uintE target) {$/;"	f
compressWeightedEdges	./apps/byteRLE-pd.h	/^long compressWeightedEdges(uchar *start, long curOffset, intEPair* savedEdges, uintE edgeI, int numBytes, int numBytesWeight, uintT runlength) {$/;"	f
compressWeightedEdges	./apps/byteRLE.h	/^long compressWeightedEdges(uchar *start, long curOffset, intEPair* savedEdges, uintE edgeI, int numBytes, int numBytesWeight, uintT runlength) {$/;"	f
compressWeightedEdges	./ligra/byteRLE-pd.h	/^long compressWeightedEdges(uchar *start, long curOffset, intEPair* savedEdges, uintE edgeI, int numBytes, int numBytesWeight, uintT runlength) {$/;"	f
compressWeightedEdges	./ligra/byteRLE.h	/^long compressWeightedEdges(uchar *start, long curOffset, intEPair* savedEdges, uintE edgeI, int numBytes, int numBytesWeight, uintT runlength) {$/;"	f
compressWeightedEdges	./tutorial/byteRLE-pd.h	/^long compressWeightedEdges(uchar *start, long curOffset, intEPair* savedEdges, uintE edgeI, int numBytes, int numBytesWeight, uintT runlength) {$/;"	f
compressWeightedEdges	./tutorial/byteRLE.h	/^long compressWeightedEdges(uchar *start, long curOffset, intEPair* savedEdges, uintE edgeI, int numBytes, int numBytesWeight, uintT runlength) {$/;"	f
compressedAsymmetricVertex	./apps/compressedVertex.h	/^struct compressedAsymmetricVertex {$/;"	s
compressedAsymmetricVertex	./ligra/compressedVertex.h	/^struct compressedAsymmetricVertex {$/;"	s
compressedAsymmetricVertex	./tutorial/compressedVertex.h	/^struct compressedAsymmetricVertex {$/;"	s
compressedSymmetricVertex	./apps/compressedVertex.h	/^struct compressedSymmetricVertex {$/;"	s
compressedSymmetricVertex	./ligra/compressedVertex.h	/^struct compressedSymmetricVertex {$/;"	s
compressedSymmetricVertex	./tutorial/compressedVertex.h	/^struct compressedSymmetricVertex {$/;"	s
cond	./apps/BC.C	/^  inline bool cond (uintE d) { return Visited[d] == 0; } \/\/check if visited$/;"	f	struct:BC_Back_F
cond	./apps/BC.C	/^  inline bool cond (uintE d) { return Visited[d] == 0; } \/\/check if visited$/;"	f	struct:BC_F
cond	./apps/BFS-Bitvector.C	/^  inline bool cond (uintE d) { $/;"	f	struct:BFS_F
cond	./apps/BFS.C	/^  inline bool cond (uintE d) { return (Parents[d] == UINT_E_MAX); } $/;"	f	struct:BFS_F
cond	./apps/BFSCC.C	/^  inline bool cond (uintE d) { return (Parents[d] == UINT_E_MAX); } $/;"	f	struct:BFS_F
cond	./apps/BellmanFord.C	/^  inline bool cond (uintE d) { return cond_true(d); }$/;"	f	struct:BF_F
cond	./apps/CF.C	/^  inline bool cond (intT d) { return cond_true(d); }};$/;"	f	struct:CF_Edge_F
cond	./apps/Components.C	/^  inline bool cond (uintE d) { $/;"	f	struct:CC_F
cond	./apps/KCore.C	/^  inline bool cond (uintE d) { return Degrees[d] > 0; }$/;"	f	struct:Update_Deg
cond	./apps/MIS.C	/^  inline bool cond (uintE i) {return cond_true(i);}$/;"	f	struct:MIS_Update
cond	./apps/MaxDegree.C	/^    inline bool cond (uintE d) {$/;"	f	struct:MAXDEG_F
cond	./apps/MaxDegree.C	/^  inline bool cond (uintE d) { return (Parents[d] == UINT_E_MAX); } $/;"	f	struct:BFS_F
cond	./apps/PageRank.C	/^  inline bool cond (intT d) { return cond_true(d); }$/;"	f	struct:PR_F
cond	./apps/PageRankDelta.C	/^  inline bool cond (uintE d) { return cond_true(d); }};$/;"	f	struct:PR_F
cond	./apps/Radii.C	/^  inline bool cond (uintE d) { return cond_true(d); }$/;"	f	struct:Radii_F
cond	./apps/Triangle.C	/^  inline bool cond (uintE d) { return cond_true(d); } \/\/does nothing$/;"	f	struct:countF
cond	./apps/eccentricity/CCBFS.h	/^  inline bool cond(const uintE &d) { return Labels[d] == INT_E_MAX;}};$/;"	f	struct:CCBFS_F
cond	./apps/eccentricity/CCBFS.h	/^  inline bool cond(const uintE &d) { return prevIDs[d] >= 0;}};$/;"	f	struct:CC_F
cond	./apps/eccentricity/CLRSTV.C	/^  inline bool cond(const uintE &d) { return Dist[d] == UINT_E_MAX;}};$/;"	f	struct:BFS_F
cond	./apps/eccentricity/FM-Ecc.C	/^  inline bool cond(const uintE &i) { return cond_true(i);}};$/;"	f	struct:Ecc_F
cond	./apps/eccentricity/LogLog-Ecc.C	/^  inline bool cond(const uintE &i) { return cond_true(i);}};$/;"	f	struct:Ecc_F
cond	./apps/eccentricity/RV.C	/^  inline bool cond(const uintE &d) { return Dist[d] == UINT_E_MAX;}};$/;"	f	struct:BFS_F
cond	./apps/eccentricity/RV.C	/^  inline bool cond(const uintE &d) { return Dist[d].first == UINT_E_MAX;}};$/;"	f	struct:BFS_Pair_F
cond	./apps/eccentricity/Simple-Approx-Ecc.C	/^  inline bool cond(const uintE &d) { return Dist[d] == UINT_E_MAX;}};$/;"	f	struct:BFS_F
cond	./apps/eccentricity/TK.C	/^  inline bool cond(const uintE &d) { return Dist[d] == UINT_E_MAX;}};$/;"	f	struct:BFS_F
cond	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  inline bool cond(const uintE &i) {return cond_true(i);}};$/;"	f	struct:Ecc_F
cond	./apps/eccentricity/kBFS-Ecc.C	/^  inline bool cond(const uintE &i) {return cond_true(i);}};$/;"	f	struct:Ecc_F
cond	./apps/eccentricity/kBFS-Exact.C	/^  inline bool cond(const uintE &i) { return cond_true(i);}};$/;"	f	struct:Ecc_F
cond	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  inline bool cond (intT d) { return cond_true(d); }}; $/;"	f	struct:ACL_F
cond	./apps/localAlg/ACL-Sync-Local.C	/^  inline bool cond (intT d) { return cond_true(d); }}; $/;"	f	struct:ACL_F
cond	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool cond (intT d) { return cond_true(d); }}; $/;"	f	struct:HK_F
cond	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool cond (intT d) { return cond_true(d); }}; $/;"	f	struct:HK_Last_F
cond	./apps/localAlg/Nibble-Parallel.C	/^  inline bool cond (intT d) { return cond_true(d); }}; $/;"	f	struct:Nibble_F
cond	./tutorial/BFS.C	/^  inline bool cond (long d) { $/;"	f	struct:BFS_F
cond	./tutorial/BellmanFord.C	/^  inline bool cond (long d) { $/;"	f	struct:BF_F
cond	./tutorial/Components.C	/^  inline bool cond (long d) { $/;"	f	struct:CC_F
cond	./tutorial/KCore.C	/^  inline bool cond (long d) { $/;"	f	struct:Update_Deg
cond	./tutorial/Radii.C	/^  inline bool cond (long d) { $/;"	f	struct:Radii_F
cond_true	./apps/ligra.h	/^inline bool cond_true (intT d) { return 1; }$/;"	f
cond_true	./ligra/ligra.h	/^inline bool cond_true (intT d) { return 1; }$/;"	f
cond_true	./tutorial/ligra.h	/^inline bool cond_true (intT d) { return 1; }$/;"	f
conductance	./apps/localAlg/sweep.h	/^  double conductance;$/;"	m	struct:sweepObject
constantOverPsi	./apps/localAlg/HeatKernel-Parallel.C	/^  double constantOverPsi;$/;"	m	struct:activeF	file:
copy	./apps/localAlg/sparseSet.h	/^  void copy(sparseAdditiveSet<E> &A) {$/;"	f	class:sparseAdditiveSet
copy	./utils/graphIO.h	/^  graph copy() {$/;"	f	struct:graph
copy	./utils/graphIO.h	/^  wghGraph copy() {$/;"	f	struct:wghGraph
coreNumbers	./apps/KCore.C	/^  uintE* coreNumbers;$/;"	m	struct:Deg_LessThan_K	file:
coreNumbers	./tutorial/KCore.C	/^  long* coreNumbers;$/;"	m	struct:Deg_LessThan_K	file:
count	./apps/localAlg/sparseSet.h	/^  intT count() {$/;"	f	class:sparseAdditiveSet
countCommon	./apps/Triangle.C	/^long countCommon(vertex& A, vertex& B, uintE a, uintE b) { $/;"	f
countF	./apps/Triangle.C	/^  countF(vertex* _V, long* _counts) : V(_V), counts(_counts) {}$/;"	f	struct:countF
countF	./apps/Triangle.C	/^struct countF { \/\/for edgeMap$/;"	s	file:
counts	./apps/Triangle.C	/^  long* counts; $/;"	m	struct:countF	file:
counts	./apps/Triangle.C	/^  long* counts;$/;"	m	struct:initF	file:
d	./apps/vertexSubset.h	/^  bool* d;$/;"	m	struct:vertexSubset
d	./ligra/vertexSubset.h	/^  bool* d;$/;"	m	struct:vertexSubset
d	./tutorial/vertexSubset.h	/^  bool* d;$/;"	m	struct:vertexSubset
damping	./apps/PageRank.C	/^  double damping;$/;"	m	struct:PR_Vertex_F	file:
damping	./apps/PageRankDelta.C	/^  double damping, addedConstant, one_over_n, epsilon2;$/;"	m	struct:PR_Vertex_F_FirstRound	file:
damping	./apps/PageRankDelta.C	/^  double damping, epsilon2;$/;"	m	struct:PR_Vertex_F	file:
decode	./apps/byte-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./apps/byte.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./apps/byteRLE-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./apps/byteRLE.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./apps/nibble-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {  $/;"	f
decode	./apps/nibble.h	/^  inline void decode(T t, F &f, uchar* edgeArr, const uintE &source, const uintT &degree) {$/;"	f
decode	./ligra/byte-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./ligra/byte.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./ligra/byteRLE-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./ligra/byteRLE.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./ligra/nibble-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {  $/;"	f
decode	./ligra/nibble.h	/^  inline void decode(T t, F &f, uchar* edgeArr, const uintE &source, const uintT &degree) {$/;"	f
decode	./tutorial/byte-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./tutorial/byte.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./tutorial/byteRLE-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./tutorial/byteRLE.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decode	./tutorial/nibble-pd.h	/^  inline void decode(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {  $/;"	f
decode	./tutorial/nibble.h	/^  inline void decode(T t, F &f, uchar* edgeArr, const uintE &source, const uintT &degree) {$/;"	f
decodeInNghBreakEarly	./apps/compressedVertex.h	/^  inline void decodeInNghBreakEarly(V* v, long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	namespace:decode_compressed
decodeInNghBreakEarly	./apps/compressedVertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:compressedAsymmetricVertex
decodeInNghBreakEarly	./apps/compressedVertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:compressedSymmetricVertex
decodeInNghBreakEarly	./apps/vertex.h	/^  inline void decodeInNghBreakEarly(V* v, long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	namespace:decode_uncompressed
decodeInNghBreakEarly	./apps/vertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:asymmetricVertex
decodeInNghBreakEarly	./apps/vertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:symmetricVertex
decodeInNghBreakEarly	./ligra/compressedVertex.h	/^  inline void decodeInNghBreakEarly(V* v, long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	namespace:decode_compressed
decodeInNghBreakEarly	./ligra/compressedVertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:compressedAsymmetricVertex
decodeInNghBreakEarly	./ligra/compressedVertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:compressedSymmetricVertex
decodeInNghBreakEarly	./ligra/vertex.h	/^  inline void decodeInNghBreakEarly(V* v, long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	namespace:decode_uncompressed
decodeInNghBreakEarly	./ligra/vertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:asymmetricVertex
decodeInNghBreakEarly	./ligra/vertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:symmetricVertex
decodeInNghBreakEarly	./tutorial/compressedVertex.h	/^  inline void decodeInNghBreakEarly(V* v, long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	namespace:decode_compressed
decodeInNghBreakEarly	./tutorial/compressedVertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:compressedAsymmetricVertex
decodeInNghBreakEarly	./tutorial/compressedVertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:compressedSymmetricVertex
decodeInNghBreakEarly	./tutorial/vertex.h	/^  inline void decodeInNghBreakEarly(V* v, long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	namespace:decode_uncompressed
decodeInNghBreakEarly	./tutorial/vertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:asymmetricVertex
decodeInNghBreakEarly	./tutorial/vertex.h	/^  inline void decodeInNghBreakEarly(long i, bool* vertexSubset, F &f, bool* next, bool parallel = 0) {$/;"	f	struct:symmetricVertex
decodeOutNgh	./apps/compressedVertex.h	/^  inline void decodeOutNgh(V* v, long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	namespace:decode_compressed
decodeOutNgh	./apps/compressedVertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:compressedAsymmetricVertex
decodeOutNgh	./apps/compressedVertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:compressedSymmetricVertex
decodeOutNgh	./apps/vertex.h	/^  inline void decodeOutNgh(V* v, long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	namespace:decode_uncompressed
decodeOutNgh	./apps/vertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:asymmetricVertex
decodeOutNgh	./apps/vertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:symmetricVertex
decodeOutNgh	./ligra/compressedVertex.h	/^  inline void decodeOutNgh(V* v, long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	namespace:decode_compressed
decodeOutNgh	./ligra/compressedVertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:compressedAsymmetricVertex
decodeOutNgh	./ligra/compressedVertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:compressedSymmetricVertex
decodeOutNgh	./ligra/vertex.h	/^  inline void decodeOutNgh(V* v, long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	namespace:decode_uncompressed
decodeOutNgh	./ligra/vertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:asymmetricVertex
decodeOutNgh	./ligra/vertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:symmetricVertex
decodeOutNgh	./tutorial/compressedVertex.h	/^  inline void decodeOutNgh(V* v, long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	namespace:decode_compressed
decodeOutNgh	./tutorial/compressedVertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:compressedAsymmetricVertex
decodeOutNgh	./tutorial/compressedVertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:compressedSymmetricVertex
decodeOutNgh	./tutorial/vertex.h	/^  inline void decodeOutNgh(V* v, long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	namespace:decode_uncompressed
decodeOutNgh	./tutorial/vertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:asymmetricVertex
decodeOutNgh	./tutorial/vertex.h	/^  inline void decodeOutNgh(long i, bool* vertexSubset, F &f, bool* next) {$/;"	f	struct:symmetricVertex
decodeOutNghSparse	./apps/compressedVertex.h	/^  inline void decodeOutNghSparse(V* v, long i, uintT o, F &f, uintE* outEdges) {$/;"	f	namespace:decode_compressed
decodeOutNghSparse	./apps/compressedVertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:compressedAsymmetricVertex
decodeOutNghSparse	./apps/compressedVertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:compressedSymmetricVertex
decodeOutNghSparse	./apps/vertex.h	/^  inline void decodeOutNghSparse(V* v, long i, uintT o, F &f, uintE* outEdges) {$/;"	f	namespace:decode_uncompressed
decodeOutNghSparse	./apps/vertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:asymmetricVertex
decodeOutNghSparse	./apps/vertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:symmetricVertex
decodeOutNghSparse	./ligra/compressedVertex.h	/^  inline void decodeOutNghSparse(V* v, long i, uintT o, F &f, uintE* outEdges) {$/;"	f	namespace:decode_compressed
decodeOutNghSparse	./ligra/compressedVertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:compressedAsymmetricVertex
decodeOutNghSparse	./ligra/compressedVertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:compressedSymmetricVertex
decodeOutNghSparse	./ligra/vertex.h	/^  inline void decodeOutNghSparse(V* v, long i, uintT o, F &f, uintE* outEdges) {$/;"	f	namespace:decode_uncompressed
decodeOutNghSparse	./ligra/vertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:asymmetricVertex
decodeOutNghSparse	./ligra/vertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:symmetricVertex
decodeOutNghSparse	./tutorial/compressedVertex.h	/^  inline void decodeOutNghSparse(V* v, long i, uintT o, F &f, uintE* outEdges) {$/;"	f	namespace:decode_compressed
decodeOutNghSparse	./tutorial/compressedVertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:compressedAsymmetricVertex
decodeOutNghSparse	./tutorial/compressedVertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:compressedSymmetricVertex
decodeOutNghSparse	./tutorial/vertex.h	/^  inline void decodeOutNghSparse(V* v, long i, uintT o, F &f, uintE* outEdges) {$/;"	f	namespace:decode_uncompressed
decodeOutNghSparse	./tutorial/vertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:asymmetricVertex
decodeOutNghSparse	./tutorial/vertex.h	/^  inline void decodeOutNghSparse(long i, uintT o, F &f, uintE* outEdges) {$/;"	f	struct:symmetricVertex
decodeWgh	./apps/byte-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./apps/byte.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./apps/byteRLE-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./apps/byteRLE.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./apps/nibble-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./apps/nibble.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./ligra/byte-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./ligra/byte.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./ligra/byteRLE-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./ligra/byteRLE.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./ligra/nibble-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./ligra/nibble.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./tutorial/byte-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./tutorial/byte.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./tutorial/byteRLE-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./tutorial/byteRLE.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source, const uintT &degree) {$/;"	f
decodeWgh	./tutorial/nibble-pd.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decodeWgh	./tutorial/nibble.h	/^  inline void decodeWgh(T t, F &f, uchar* edgeStart, const uintE &source,const uintT &degree) {$/;"	f
decode_compressed	./apps/compressedVertex.h	/^namespace decode_compressed {$/;"	n
decode_compressed	./ligra/compressedVertex.h	/^namespace decode_compressed {$/;"	n
decode_compressed	./tutorial/compressedVertex.h	/^namespace decode_compressed {$/;"	n
decode_first_edge	./apps/nibble-pd.h	/^inline uintE decode_first_edge(uchar* &start, long* location, uintE source) {$/;"	f
decode_first_edge	./apps/nibble.h	/^inline uintE decode_first_edge(uchar* &start, long* location, uintE source) {$/;"	f
decode_first_edge	./ligra/nibble-pd.h	/^inline uintE decode_first_edge(uchar* &start, long* location, uintE source) {$/;"	f
decode_first_edge	./ligra/nibble.h	/^inline uintE decode_first_edge(uchar* &start, long* location, uintE source) {$/;"	f
decode_first_edge	./tutorial/nibble-pd.h	/^inline uintE decode_first_edge(uchar* &start, long* location, uintE source) {$/;"	f
decode_first_edge	./tutorial/nibble.h	/^inline uintE decode_first_edge(uchar* &start, long* location, uintE source) {$/;"	f
decode_next_edge	./apps/nibble-pd.h	/^inline uintE decode_next_edge(uchar* &start, long* location) {$/;"	f
decode_next_edge	./apps/nibble.h	/^inline uintE decode_next_edge(uchar* &start, long* location) {$/;"	f
decode_next_edge	./ligra/nibble-pd.h	/^inline uintE decode_next_edge(uchar* &start, long* location) {$/;"	f
decode_next_edge	./ligra/nibble.h	/^inline uintE decode_next_edge(uchar* &start, long* location) {$/;"	f
decode_next_edge	./tutorial/nibble-pd.h	/^inline uintE decode_next_edge(uchar* &start, long* location) {$/;"	f
decode_next_edge	./tutorial/nibble.h	/^inline uintE decode_next_edge(uchar* &start, long* location) {$/;"	f
decode_uncompressed	./apps/vertex.h	/^namespace decode_uncompressed {$/;"	n
decode_uncompressed	./ligra/vertex.h	/^namespace decode_uncompressed {$/;"	n
decode_uncompressed	./tutorial/vertex.h	/^namespace decode_uncompressed {$/;"	n
decode_val_nibblecode	./apps/nibble-pd.h	44;"	d
decode_val_nibblecode	./apps/nibble.h	42;"	d
decode_val_nibblecode	./ligra/nibble-pd.h	44;"	d
decode_val_nibblecode	./ligra/nibble.h	42;"	d
decode_val_nibblecode	./tutorial/nibble-pd.h	44;"	d
decode_val_nibblecode	./tutorial/nibble.h	42;"	d
degree	./apps/compressedVertex.h	/^  uintT degree;$/;"	m	struct:compressedSymmetricVertex
degree	./apps/vertex.h	/^  uintT degree;$/;"	m	struct:symmetricVertex
degree	./ligra/compressedVertex.h	/^  uintT degree;$/;"	m	struct:compressedSymmetricVertex
degree	./ligra/vertex.h	/^  uintT degree;$/;"	m	struct:symmetricVertex
degree	./tutorial/compressedVertex.h	/^  uintT degree;$/;"	m	struct:compressedSymmetricVertex
degree	./tutorial/vertex.h	/^  uintT degree;$/;"	m	struct:symmetricVertex
degree	./utils/graphIO.h	/^  intT degree;$/;"	m	struct:vertex
degree	./utils/graphIO.h	/^  intT degree;$/;"	m	struct:wghVertex
del	./apps/IO.h	/^  void del() {$/;"	f	struct:Compressed_Mem
del	./apps/IO.h	/^  void del() {$/;"	f	struct:Uncompressed_Mem
del	./apps/IO.h	/^  void del() {free(Chars); free(Strings);}$/;"	f	struct:words
del	./apps/compressedVertex.h	/^  void del() {}$/;"	f	struct:compressedAsymmetricVertex
del	./apps/compressedVertex.h	/^  void del() {}$/;"	f	struct:compressedSymmetricVertex
del	./apps/graph.h	/^  void del() {$/;"	f	struct:graph
del	./apps/localAlg/sparseSet.h	/^  void del() {$/;"	f	class:sparseAdditiveSet
del	./apps/utils.h	/^  void del() {free(A);}$/;"	f	struct:_seq
del	./apps/vertex.h	/^  void del() {free(inNeighbors); free(outNeighbors);}$/;"	f	struct:asymmetricVertex
del	./apps/vertex.h	/^  void del() {free(neighbors); }$/;"	f	struct:symmetricVertex
del	./apps/vertexSubset.h	/^  void del(){$/;"	f	struct:vertexSubset
del	./ligra/IO.h	/^  void del() {$/;"	f	struct:Compressed_Mem
del	./ligra/IO.h	/^  void del() {$/;"	f	struct:Uncompressed_Mem
del	./ligra/IO.h	/^  void del() {free(Chars); free(Strings);}$/;"	f	struct:words
del	./ligra/compressedVertex.h	/^  void del() {}$/;"	f	struct:compressedAsymmetricVertex
del	./ligra/compressedVertex.h	/^  void del() {}$/;"	f	struct:compressedSymmetricVertex
del	./ligra/graph.h	/^  void del() {$/;"	f	struct:graph
del	./ligra/utils.h	/^  void del() {free(A);}$/;"	f	struct:_seq
del	./ligra/vertex.h	/^  void del() {free(inNeighbors); free(outNeighbors);}$/;"	f	struct:asymmetricVertex
del	./ligra/vertex.h	/^  void del() {free(neighbors); }$/;"	f	struct:symmetricVertex
del	./ligra/vertexSubset.h	/^  void del(){$/;"	f	struct:vertexSubset
del	./tutorial/IO.h	/^  void del() {$/;"	f	struct:Compressed_Mem
del	./tutorial/IO.h	/^  void del() {$/;"	f	struct:Uncompressed_Mem
del	./tutorial/IO.h	/^  void del() {free(Chars); free(Strings);}$/;"	f	struct:words
del	./tutorial/compressedVertex.h	/^  void del() {}$/;"	f	struct:compressedAsymmetricVertex
del	./tutorial/compressedVertex.h	/^  void del() {}$/;"	f	struct:compressedSymmetricVertex
del	./tutorial/graph.h	/^  void del() {$/;"	f	struct:graph
del	./tutorial/utils.h	/^  void del() {free(A);}$/;"	f	struct:_seq
del	./tutorial/vertex.h	/^  void del() {free(inNeighbors); free(outNeighbors);}$/;"	f	struct:asymmetricVertex
del	./tutorial/vertex.h	/^  void del() {free(neighbors); }$/;"	f	struct:symmetricVertex
del	./tutorial/vertexSubset.h	/^  void del(){$/;"	f	struct:vertexSubset
del	./utils/graphIO.h	/^    void del() {free(Chars); free(Strings);}$/;"	f	struct:benchIO::words
del	./utils/graphIO.h	/^  void del() {$/;"	f	struct:graph
del	./utils/graphIO.h	/^  void del() {$/;"	f	struct:wghGraph
del	./utils/graphIO.h	/^  void del() {free(E);}$/;"	f	struct:edgeArray
del	./utils/graphIO.h	/^  void del() {free(Neighbors); free(nghWeights);}$/;"	f	struct:wghVertex
del	./utils/graphIO.h	/^  void del() {free(Neighbors);}$/;"	f	struct:vertex
del	./utils/utils.h	/^  void del() {free(A);}$/;"	f	struct:_seq
denseForwardT	./apps/compressedVertex.h	/^  denseForwardT(bool* np, bool* vp) : nextArr(np), vertexArr(vp) {}$/;"	f	struct:decode_compressed::denseForwardT
denseForwardT	./apps/compressedVertex.h	/^  struct denseForwardT {$/;"	s	namespace:decode_compressed
denseForwardT	./ligra/compressedVertex.h	/^  denseForwardT(bool* np, bool* vp) : nextArr(np), vertexArr(vp) {}$/;"	f	struct:decode_compressed::denseForwardT
denseForwardT	./ligra/compressedVertex.h	/^  struct denseForwardT {$/;"	s	namespace:decode_compressed
denseForwardT	./tutorial/compressedVertex.h	/^  denseForwardT(bool* np, bool* vp) : nextArr(np), vertexArr(vp) {}$/;"	f	struct:decode_compressed::denseForwardT
denseForwardT	./tutorial/compressedVertex.h	/^  struct denseForwardT {$/;"	s	namespace:decode_compressed
denseT	./apps/compressedVertex.h	/^  denseT(bool* np, bool* vp) : nextArr(np), vertexArr(vp) {}$/;"	f	struct:decode_compressed::denseT
denseT	./apps/compressedVertex.h	/^  struct denseT {$/;"	s	namespace:decode_compressed
denseT	./ligra/compressedVertex.h	/^  denseT(bool* np, bool* vp) : nextArr(np), vertexArr(vp) {}$/;"	f	struct:decode_compressed::denseT
denseT	./ligra/compressedVertex.h	/^  struct denseT {$/;"	s	namespace:decode_compressed
denseT	./tutorial/compressedVertex.h	/^  denseT(bool* np, bool* vp) : nextArr(np), vertexArr(vp) {}$/;"	f	struct:decode_compressed::denseT
denseT	./tutorial/compressedVertex.h	/^  struct denseT {$/;"	s	namespace:decode_compressed
diPair	./apps/localAlg/sweep.h	/^typedef pair<double,intT> diPair;$/;"	t
e	./apps/localAlg/sparseSet.h	/^    kvPair e; notEmptyF(kvPair _e) : e(_e) {} $/;"	m	struct:sparseAdditiveSet::notEmptyF
eBits	./apps/blockRadixSort.h	/^      eBits(long bits, long offset, F f): _mask((1<<bits)-1), $/;"	f	struct:intSort::eBits
eBits	./apps/blockRadixSort.h	/^    struct eBits {$/;"	s	namespace:intSort
eBits	./ligra/blockRadixSort.h	/^      eBits(long bits, long offset, F f): _mask((1<<bits)-1), $/;"	f	struct:intSort::eBits
eBits	./ligra/blockRadixSort.h	/^    struct eBits {$/;"	s	namespace:intSort
eBits	./tutorial/blockRadixSort.h	/^      eBits(long bits, long offset, F f): _mask((1<<bits)-1), $/;"	f	struct:intSort::eBits
eBits	./tutorial/blockRadixSort.h	/^    struct eBits {$/;"	s	namespace:intSort
eBits	./utils/blockRadixSort.h	/^      eBits(long bits, long offset, F f): _mask((1<<bits)-1), $/;"	f	struct:intSort::eBits
eBits	./utils/blockRadixSort.h	/^    struct eBits {$/;"	s	namespace:intSort
eatEdge	./apps/byte-pd.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./apps/byte.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./apps/byteRLE-pd.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./apps/byteRLE.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./ligra/byte-pd.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./ligra/byte.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./ligra/byteRLE-pd.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./ligra/byteRLE.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./tutorial/byte-pd.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./tutorial/byte.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./tutorial/byteRLE-pd.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatEdge	./tutorial/byteRLE.h	/^inline uintE eatEdge(uchar* &start) {$/;"	f
eatFirstEdge	./apps/byte-pd.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./apps/byte.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./apps/byteRLE-pd.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./apps/byteRLE.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./ligra/byte-pd.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./ligra/byte.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./ligra/byteRLE-pd.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./ligra/byteRLE.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./tutorial/byte-pd.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./tutorial/byte.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./tutorial/byteRLE-pd.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatFirstEdge	./tutorial/byteRLE.h	/^inline intE eatFirstEdge(uchar* &start, uintE source) {$/;"	f
eatWeight	./apps/byte-pd.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./apps/byte.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./apps/byteRLE-pd.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./apps/byteRLE.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./ligra/byte-pd.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./ligra/byte.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./ligra/byteRLE-pd.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./ligra/byteRLE.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./tutorial/byte-pd.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./tutorial/byte.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./tutorial/byteRLE-pd.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
eatWeight	./tutorial/byteRLE.h	/^inline intE eatWeight(uchar* &start) {$/;"	f
ecc	./apps/eccentricity/FM-Ecc.C	/^  intE* ecc;$/;"	m	struct:Ecc_F	file:
ecc	./apps/eccentricity/LogLog-Ecc.C	/^  intE* ecc;$/;"	m	struct:Ecc_F	file:
ecc	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  uintE* ecc;$/;"	m	struct:Ecc_F	file:
ecc	./apps/eccentricity/kBFS-Ecc.C	/^  uintE* ecc;$/;"	m	struct:Ecc_F	file:
ecc	./apps/eccentricity/kBFS-Exact.C	/^  uintE* ecc;$/;"	m	struct:Ecc_F	file:
edge	./utils/graphIO.h	/^  edge(intT f, intT s) : u(f), v(s) {}$/;"	f	struct:edge
edge	./utils/graphIO.h	/^struct edge {$/;"	s
edge2DMesh	./utils/gridGraph.C	/^edgeArray<intT> edge2DMesh(intT n) {$/;"	f
edge3DMesh	./utils/gridGraph.C	/^edgeArray<intT> edge3DMesh(intT n) {$/;"	f
edgeArray	./utils/graphIO.h	/^  edgeArray() {}$/;"	f	struct:edgeArray
edgeArray	./utils/graphIO.h	/^  edgeArray(edge<intT> *EE, intT r, intT c, intT nz) :$/;"	f	struct:edgeArray
edgeArray	./utils/graphIO.h	/^struct edgeArray {$/;"	s
edgeCmp	./utils/graphIO.h	/^struct edgeCmp {$/;"	s
edgeLessPair	./apps/localAlg/sweep.h	/^struct edgeLessPair{$/;"	s
edgeMap	./apps/ligra.h	/^vertexSubset edgeMap(graph<vertex> GA, vertexSubset &V, F f, intT threshold = -1, $/;"	f
edgeMap	./ligra/ligra.h	/^vertexSubset edgeMap(graph<vertex> GA, vertexSubset &V, F f, intT threshold = -1, $/;"	f
edgeMap	./tutorial/ligra.h	/^vertexSubset edgeMap(graph<vertex> GA, vertexSubset &V, F f, intT threshold = -1, $/;"	f
edgeMapDense	./apps/ligra.h	/^bool* edgeMapDense(graph<vertex> GA, bool* vertexSubset, F &f, bool parallel = 0) {$/;"	f
edgeMapDense	./ligra/ligra.h	/^bool* edgeMapDense(graph<vertex> GA, bool* vertexSubset, F &f, bool parallel = 0) {$/;"	f
edgeMapDense	./tutorial/ligra.h	/^bool* edgeMapDense(graph<vertex> GA, bool* vertexSubset, F &f, bool parallel = 0) {$/;"	f
edgeMapDenseForward	./apps/ligra.h	/^bool* edgeMapDenseForward(graph<vertex> GA, bool* vertexSubset, F &f) {$/;"	f
edgeMapDenseForward	./ligra/ligra.h	/^bool* edgeMapDenseForward(graph<vertex> GA, bool* vertexSubset, F &f) {$/;"	f
edgeMapDenseForward	./tutorial/ligra.h	/^bool* edgeMapDenseForward(graph<vertex> GA, bool* vertexSubset, F &f) {$/;"	f
edgeMapSparse	./apps/ligra.h	/^pair<long,uintE*> edgeMapSparse(vertex* frontierVertices, uintE* indices, $/;"	f
edgeMapSparse	./ligra/ligra.h	/^pair<long,uintE*> edgeMapSparse(vertex* frontierVertices, uintE* indices, $/;"	f
edgeMapSparse	./tutorial/ligra.h	/^pair<long,uintE*> edgeMapSparse(vertex* frontierVertices, uintE* indices, $/;"	f
edgeRandomWithDimension	./utils/randLocalGraph.C	/^edgeArray<intT> edgeRandomWithDimension(intT dim, intT nonZeros, intT numRows) {$/;"	f
edgeRmat	./utils/rMatGraph.C	/^edgeArray<intT> edgeRmat(intT n, intT m, intT seed, $/;"	f
edges	./apps/IO.h	/^  uchar* edges;$/;"	m	struct:Compressed_Mem
edges	./ligra/IO.h	/^  uchar* edges;$/;"	m	struct:Compressed_Mem
edges	./tutorial/IO.h	/^  uchar* edges;$/;"	m	struct:Compressed_Mem
edges	./utils/graphIO.h	/^  intT* edges() { return allocatedInplace+2+n; }$/;"	f	struct:graph
edgesCrossing	./apps/localAlg/sweep.h	/^  long sizeS, volS, vol, edgesCrossing;$/;"	m	struct:sweepObject
empty	./apps/localAlg/sparseSet.h	/^  kvPair empty;$/;"	m	class:sparseAdditiveSet
encodeGraphFromFile	./apps/encoder.C	/^void encodeGraphFromFile(char* fname, bool isSymmetric, char* outFile, bool binary) {$/;"	f
encodeGraphFromFile	./ligra/encoder.C	/^void encodeGraphFromFile(char* fname, bool isSymmetric, char* outFile, bool binary) {$/;"	f
encodeGraphFromFile	./tutorial/encoder.C	/^void encodeGraphFromFile(char* fname, bool isSymmetric, char* outFile, bool binary) {$/;"	f
encodeWeightedGraphFromFile	./apps/encoder.C	/^void encodeWeightedGraphFromFile$/;"	f
encodeWeightedGraphFromFile	./ligra/encoder.C	/^void encodeWeightedGraphFromFile$/;"	f
encodeWeightedGraphFromFile	./tutorial/encoder.C	/^void encodeWeightedGraphFromFile$/;"	f
encode_nibbleval	./apps/nibble-pd.h	/^long encode_nibbleval(uchar* start, long offset, long val) {$/;"	f
encode_nibbleval	./apps/nibble.h	/^long encode_nibbleval(uchar* start, long offset, long val) {$/;"	f
encode_nibbleval	./ligra/nibble-pd.h	/^long encode_nibbleval(uchar* start, long offset, long val) {$/;"	f
encode_nibbleval	./ligra/nibble.h	/^long encode_nibbleval(uchar* start, long offset, long val) {$/;"	f
encode_nibbleval	./tutorial/nibble-pd.h	/^long encode_nibbleval(uchar* start, long offset, long val) {$/;"	f
encode_nibbleval	./tutorial/nibble.h	/^long encode_nibbleval(uchar* start, long offset, long val) {$/;"	f
entries	./apps/localAlg/sparseSet.h	/^  _seq<kvPair> entries() {$/;"	f	class:sparseAdditiveSet
entries	./apps/localAlg/sparseSet.h	/^  _seq<kvPair> entries(F f) {$/;"	f	class:sparseAdditiveSet
epsilon	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  double epsilon;$/;"	m	struct:activeF	file:
epsilon	./apps/localAlg/ACL-Sync-Local.C	/^  double epsilon;$/;"	m	struct:activeF	file:
epsilon	./apps/localAlg/Nibble-Parallel.C	/^  double epsilon;$/;"	m	struct:activeF	file:
epsilon2	./apps/PageRankDelta.C	/^  double damping, addedConstant, one_over_n, epsilon2;$/;"	m	struct:PR_Vertex_F_FirstRound	file:
epsilon2	./apps/PageRankDelta.C	/^  double damping, epsilon2;$/;"	m	struct:PR_Vertex_F	file:
eq	./apps/vertexSubset.h	/^  bool eq (vertexSubset& b) {$/;"	f	struct:vertexSubset
eq	./ligra/vertexSubset.h	/^  bool eq (vertexSubset& b) {$/;"	f	struct:vertexSubset
eq	./tutorial/vertexSubset.h	/^  bool eq (vertexSubset& b) {$/;"	f	struct:vertexSubset
equalPair	./apps/localAlg/HeatKernel-Serial.C	/^class equalPair {$/;"	c	file:
error	./apps/CF.C	/^  double *latent_curr, *error;$/;"	m	struct:CF_Vertex_F	file:
error	./apps/CF.C	/^  double* latent_curr, *error;$/;"	m	struct:CF_Edge_F	file:
extractSecond	./apps/localAlg/sweep.h	/^struct extractSecond {$/;"	s
f	./apps/utils.h	/^    F f;$/;"	m	struct:sequence::getAF
f	./ligra/utils.h	/^    F f;$/;"	m	struct:sequence::getAF
f	./tutorial/utils.h	/^    F f;$/;"	m	struct:sequence::getAF
f	./utils/utils.h	/^    F f;$/;"	m	struct:sequence::getAF
fType	./apps/BC.C	/^typedef double fType;$/;"	t	file:
filter	./apps/utils.h	/^  intT filter(ET* In, ET* Out, intT n, PRED p) {$/;"	f	namespace:sequence
filter	./ligra/utils.h	/^  intT filter(ET* In, ET* Out, intT n, PRED p) {$/;"	f	namespace:sequence
filter	./tutorial/utils.h	/^  intT filter(ET* In, ET* Out, intT n, PRED p) {$/;"	f	namespace:sequence
filter	./utils/utils.h	/^  intT filter(ET* In, ET* Out, intT n, PRED p) {$/;"	f	namespace:sequence
find	./apps/localAlg/sparseSet.h	/^  kvPair find(uintE v) {$/;"	f	class:sparseAdditiveSet
firstF	./apps/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	s
firstF	./ligra/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	s
firstF	./tutorial/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	s
firstF	./utils/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	s
firstIndex	./apps/localAlg/sparseSet.h	/^  inline uintT firstIndex(uintT v) {return hashToRange(hashInt(v));}$/;"	f	class:sparseAdditiveSet
flags	./apps/IO.h	/^  uintE* flags;$/;"	m	struct:Uncompressed_Mem
flags	./apps/MIS.C	/^  int* flags;$/;"	m	struct:MIS_Filter	file:
flags	./apps/MIS.C	/^  int* flags;$/;"	m	struct:MIS_Update	file:
flags	./apps/graph.h	/^  uintE* flags;$/;"	m	struct:graph
flags	./ligra/IO.h	/^  uintE* flags;$/;"	m	struct:Uncompressed_Mem
flags	./ligra/graph.h	/^  uintE* flags;$/;"	m	struct:graph
flags	./tutorial/IO.h	/^  uintE* flags;$/;"	m	struct:Uncompressed_Mem
flags	./tutorial/graph.h	/^  uintE* flags;$/;"	m	struct:graph
flipEdges	./apps/compressedVertex.h	/^  void flipEdges() { swap(inNeighbors,outNeighbors); $/;"	f	struct:compressedAsymmetricVertex
flipEdges	./apps/compressedVertex.h	/^  void flipEdges() {}$/;"	f	struct:compressedSymmetricVertex
flipEdges	./apps/vertex.h	/^  void flipEdges() { swap(inNeighbors,outNeighbors); swap(inDegree,outDegree); }$/;"	f	struct:asymmetricVertex
flipEdges	./apps/vertex.h	/^  void flipEdges() {}$/;"	f	struct:symmetricVertex
flipEdges	./ligra/compressedVertex.h	/^  void flipEdges() { swap(inNeighbors,outNeighbors); $/;"	f	struct:compressedAsymmetricVertex
flipEdges	./ligra/compressedVertex.h	/^  void flipEdges() {}$/;"	f	struct:compressedSymmetricVertex
flipEdges	./ligra/vertex.h	/^  void flipEdges() { swap(inNeighbors,outNeighbors); swap(inDegree,outDegree); }$/;"	f	struct:asymmetricVertex
flipEdges	./ligra/vertex.h	/^  void flipEdges() {}$/;"	f	struct:symmetricVertex
flipEdges	./tutorial/compressedVertex.h	/^  void flipEdges() { swap(inNeighbors,outNeighbors); $/;"	f	struct:compressedAsymmetricVertex
flipEdges	./tutorial/compressedVertex.h	/^  void flipEdges() {}$/;"	f	struct:compressedSymmetricVertex
flipEdges	./tutorial/vertex.h	/^  void flipEdges() { swap(inNeighbors,outNeighbors); swap(inDegree,outDegree); }$/;"	f	struct:asymmetricVertex
flipEdges	./tutorial/vertex.h	/^  void flipEdges() {}$/;"	f	struct:symmetricVertex
gapCost	./apps/encoder.C	/^void gapCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){$/;"	f
gapCost	./ligra/encoder.C	/^void gapCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){$/;"	f
gapCost	./tutorial/encoder.C	/^void gapCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){$/;"	f
getA	./apps/utils.h	/^    getA(ET* AA) : A(AA) {}$/;"	f	struct:sequence::getA
getA	./apps/utils.h	/^  struct getA {$/;"	s	namespace:sequence
getA	./ligra/utils.h	/^    getA(ET* AA) : A(AA) {}$/;"	f	struct:sequence::getA
getA	./ligra/utils.h	/^  struct getA {$/;"	s	namespace:sequence
getA	./tutorial/utils.h	/^    getA(ET* AA) : A(AA) {}$/;"	f	struct:sequence::getA
getA	./tutorial/utils.h	/^  struct getA {$/;"	s	namespace:sequence
getA	./utils/utils.h	/^    getA(ET* AA) : A(AA) {}$/;"	f	struct:sequence::getA
getA	./utils/utils.h	/^  struct getA {$/;"	s	namespace:sequence
getAF	./apps/utils.h	/^    getAF(IT* AA, F ff) : A(AA), f(ff) {}$/;"	f	struct:sequence::getAF
getAF	./apps/utils.h	/^  struct getAF {$/;"	s	namespace:sequence
getAF	./ligra/utils.h	/^    getAF(IT* AA, F ff) : A(AA), f(ff) {}$/;"	f	struct:sequence::getAF
getAF	./ligra/utils.h	/^  struct getAF {$/;"	s	namespace:sequence
getAF	./tutorial/utils.h	/^    getAF(IT* AA, F ff) : A(AA), f(ff) {}$/;"	f	struct:sequence::getAF
getAF	./tutorial/utils.h	/^  struct getAF {$/;"	s	namespace:sequence
getAF	./utils/utils.h	/^    getAF(IT* AA, F ff) : A(AA), f(ff) {}$/;"	f	struct:sequence::getAF
getAF	./utils/utils.h	/^  struct getAF {$/;"	s	namespace:sequence
getArgument	./apps/parseCommandLine.h	/^  char* getArgument(int i) {$/;"	f	struct:commandLine
getArgument	./ligra/parseCommandLine.h	/^  char* getArgument(int i) {$/;"	f	struct:commandLine
getArgument	./tutorial/parseCommandLine.h	/^  char* getArgument(int i) {$/;"	f	struct:commandLine
getArgument	./utils/parseCommandLine.h	/^  char* getArgument(int i) {$/;"	f	struct:commandLine
getDegree	./apps/eccentricity/CLRSTV.C	/^  getDegree(vertex* VV) : V(VV) {}$/;"	f	struct:getDegree
getDegree	./apps/eccentricity/CLRSTV.C	/^struct getDegree {$/;"	s	file:
getDegree	./apps/eccentricity/RV.C	/^  getDegree(vertex* VV) : V(VV) {}$/;"	f	struct:getDegree
getDegree	./apps/eccentricity/RV.C	/^struct getDegree {$/;"	s	file:
getDegree	./apps/eccentricity/Simple-Approx-Ecc.C	/^  getDegree(vertex* VV) : V(VV) {}$/;"	f	struct:getDegree
getDegree	./apps/eccentricity/Simple-Approx-Ecc.C	/^struct getDegree {$/;"	s	file:
getDegree	./apps/eccentricity/TK.C	/^  getDegree(vertex* VV) : V(VV) {}$/;"	f	struct:getDegree
getDegree	./apps/eccentricity/TK.C	/^struct getDegree {$/;"	s	file:
getDegree	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  getDegree(vertex* VV) : V(VV) {}$/;"	f	struct:getDegree
getDegree	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^struct getDegree {$/;"	s	file:
getDegree	./apps/eccentricity/kBFS-Ecc.C	/^  getDegree(vertex* VV) : V(VV) {}$/;"	f	struct:getDegree
getDegree	./apps/eccentricity/kBFS-Ecc.C	/^struct getDegree {$/;"	s	file:
getFirst	./apps/IO.h	/^struct getFirst {uintE operator() (pair<uintE,E> a) {return a.first;} };$/;"	s
getFirst	./ligra/IO.h	/^struct getFirst {uintE operator() (pair<uintE,E> a) {return a.first;} };$/;"	s
getFirst	./tutorial/IO.h	/^struct getFirst {uintE operator() (pair<uintE,E> a) {return a.first;} };$/;"	s
getInDegree	./apps/compressedVertex.h	/^  uintT getInDegree() { return degree; }$/;"	f	struct:compressedSymmetricVertex
getInDegree	./apps/compressedVertex.h	/^  uintT getInDegree() { return inDegree; }$/;"	f	struct:compressedAsymmetricVertex
getInDegree	./apps/vertex.h	/^  uintT getInDegree() { return degree; }$/;"	f	struct:symmetricVertex
getInDegree	./apps/vertex.h	/^  uintT getInDegree() { return inDegree; }$/;"	f	struct:asymmetricVertex
getInDegree	./ligra/compressedVertex.h	/^  uintT getInDegree() { return degree; }$/;"	f	struct:compressedSymmetricVertex
getInDegree	./ligra/compressedVertex.h	/^  uintT getInDegree() { return inDegree; }$/;"	f	struct:compressedAsymmetricVertex
getInDegree	./ligra/vertex.h	/^  uintT getInDegree() { return degree; }$/;"	f	struct:symmetricVertex
getInDegree	./ligra/vertex.h	/^  uintT getInDegree() { return inDegree; }$/;"	f	struct:asymmetricVertex
getInDegree	./tutorial/compressedVertex.h	/^  uintT getInDegree() { return degree; }$/;"	f	struct:compressedSymmetricVertex
getInDegree	./tutorial/compressedVertex.h	/^  uintT getInDegree() { return inDegree; }$/;"	f	struct:compressedAsymmetricVertex
getInDegree	./tutorial/vertex.h	/^  uintT getInDegree() { return degree; }$/;"	f	struct:symmetricVertex
getInDegree	./tutorial/vertex.h	/^  uintT getInDegree() { return inDegree; }$/;"	f	struct:asymmetricVertex
getInNeighbor	./apps/compressedVertex.h	/^  intT getInNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedAsymmetricVertex
getInNeighbor	./apps/compressedVertex.h	/^  intT getInNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedSymmetricVertex
getInNeighbor	./apps/vertex.h	/^  intE getInNeighbor(intT j) { return neighbors[2*j]; }$/;"	f	struct:symmetricVertex
getInNeighbor	./apps/vertex.h	/^  intE getInNeighbor(uintT j) { return inNeighbors[2*j]; }$/;"	f	struct:asymmetricVertex
getInNeighbor	./apps/vertex.h	/^  uintE getInNeighbor(uintT j) { return inNeighbors[j]; }$/;"	f	struct:asymmetricVertex
getInNeighbor	./apps/vertex.h	/^  uintE getInNeighbor(uintT j) { return neighbors[j]; }$/;"	f	struct:symmetricVertex
getInNeighbor	./ligra/compressedVertex.h	/^  intT getInNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedAsymmetricVertex
getInNeighbor	./ligra/compressedVertex.h	/^  intT getInNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedSymmetricVertex
getInNeighbor	./ligra/vertex.h	/^  intE getInNeighbor(intT j) { return neighbors[2*j]; }$/;"	f	struct:symmetricVertex
getInNeighbor	./ligra/vertex.h	/^  intE getInNeighbor(uintT j) { return inNeighbors[2*j]; }$/;"	f	struct:asymmetricVertex
getInNeighbor	./ligra/vertex.h	/^  uintE getInNeighbor(uintT j) { return inNeighbors[j]; }$/;"	f	struct:asymmetricVertex
getInNeighbor	./ligra/vertex.h	/^  uintE getInNeighbor(uintT j) { return neighbors[j]; }$/;"	f	struct:symmetricVertex
getInNeighbor	./tutorial/compressedVertex.h	/^  intT getInNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedAsymmetricVertex
getInNeighbor	./tutorial/compressedVertex.h	/^  intT getInNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedSymmetricVertex
getInNeighbor	./tutorial/vertex.h	/^  intE getInNeighbor(intT j) { return neighbors[2*j]; }$/;"	f	struct:symmetricVertex
getInNeighbor	./tutorial/vertex.h	/^  intE getInNeighbor(uintT j) { return inNeighbors[2*j]; }$/;"	f	struct:asymmetricVertex
getInNeighbor	./tutorial/vertex.h	/^  uintE getInNeighbor(uintT j) { return inNeighbors[j]; }$/;"	f	struct:asymmetricVertex
getInNeighbor	./tutorial/vertex.h	/^  uintE getInNeighbor(uintT j) { return neighbors[j]; }$/;"	f	struct:symmetricVertex
getInNeighbors	./apps/compressedVertex.h	/^  uchar* getInNeighbors() { return inNeighbors; }$/;"	f	struct:compressedAsymmetricVertex
getInNeighbors	./apps/compressedVertex.h	/^  uchar* getInNeighbors() { return neighbors; }$/;"	f	struct:compressedSymmetricVertex
getInNeighbors	./apps/vertex.h	/^  intE* getInNeighbors () { return inNeighbors; }$/;"	f	struct:asymmetricVertex
getInNeighbors	./apps/vertex.h	/^  intE* getInNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getInNeighbors	./apps/vertex.h	/^  uintE* getInNeighbors () { return inNeighbors; }$/;"	f	struct:asymmetricVertex
getInNeighbors	./apps/vertex.h	/^  uintE* getInNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getInNeighbors	./ligra/compressedVertex.h	/^  uchar* getInNeighbors() { return inNeighbors; }$/;"	f	struct:compressedAsymmetricVertex
getInNeighbors	./ligra/compressedVertex.h	/^  uchar* getInNeighbors() { return neighbors; }$/;"	f	struct:compressedSymmetricVertex
getInNeighbors	./ligra/vertex.h	/^  intE* getInNeighbors () { return inNeighbors; }$/;"	f	struct:asymmetricVertex
getInNeighbors	./ligra/vertex.h	/^  intE* getInNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getInNeighbors	./ligra/vertex.h	/^  uintE* getInNeighbors () { return inNeighbors; }$/;"	f	struct:asymmetricVertex
getInNeighbors	./ligra/vertex.h	/^  uintE* getInNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getInNeighbors	./tutorial/compressedVertex.h	/^  uchar* getInNeighbors() { return inNeighbors; }$/;"	f	struct:compressedAsymmetricVertex
getInNeighbors	./tutorial/compressedVertex.h	/^  uchar* getInNeighbors() { return neighbors; }$/;"	f	struct:compressedSymmetricVertex
getInNeighbors	./tutorial/vertex.h	/^  intE* getInNeighbors () { return inNeighbors; }$/;"	f	struct:asymmetricVertex
getInNeighbors	./tutorial/vertex.h	/^  intE* getInNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getInNeighbors	./tutorial/vertex.h	/^  uintE* getInNeighbors () { return inNeighbors; }$/;"	f	struct:asymmetricVertex
getInNeighbors	./tutorial/vertex.h	/^  uintE* getInNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getInWeight	./apps/vertex.h	/^  intE getInWeight(intT j) { return neighbors[2*j+1]; }$/;"	f	struct:symmetricVertex
getInWeight	./apps/vertex.h	/^  intE getInWeight(uintT j) { return inNeighbors[2*j+1]; }$/;"	f	struct:asymmetricVertex
getInWeight	./ligra/vertex.h	/^  intE getInWeight(intT j) { return neighbors[2*j+1]; }$/;"	f	struct:symmetricVertex
getInWeight	./ligra/vertex.h	/^  intE getInWeight(uintT j) { return inNeighbors[2*j+1]; }$/;"	f	struct:asymmetricVertex
getInWeight	./tutorial/vertex.h	/^  intE getInWeight(intT j) { return neighbors[2*j+1]; }$/;"	f	struct:symmetricVertex
getInWeight	./tutorial/vertex.h	/^  intE getInWeight(uintT j) { return inNeighbors[2*j+1]; }$/;"	f	struct:asymmetricVertex
getOption	./apps/parseCommandLine.h	/^  bool getOption(string option) {$/;"	f	struct:commandLine
getOption	./ligra/parseCommandLine.h	/^  bool getOption(string option) {$/;"	f	struct:commandLine
getOption	./tutorial/parseCommandLine.h	/^  bool getOption(string option) {$/;"	f	struct:commandLine
getOption	./utils/parseCommandLine.h	/^  bool getOption(string option) {$/;"	f	struct:commandLine
getOptionDoubleValue	./apps/parseCommandLine.h	/^  double getOptionDoubleValue(string option, double defaultValue) {$/;"	f	struct:commandLine
getOptionDoubleValue	./ligra/parseCommandLine.h	/^  double getOptionDoubleValue(string option, double defaultValue) {$/;"	f	struct:commandLine
getOptionDoubleValue	./tutorial/parseCommandLine.h	/^  double getOptionDoubleValue(string option, double defaultValue) {$/;"	f	struct:commandLine
getOptionDoubleValue	./utils/parseCommandLine.h	/^  double getOptionDoubleValue(string option, double defaultValue) {$/;"	f	struct:commandLine
getOptionIntValue	./apps/parseCommandLine.h	/^  int getOptionIntValue(string option, int defaultValue) {$/;"	f	struct:commandLine
getOptionIntValue	./ligra/parseCommandLine.h	/^  int getOptionIntValue(string option, int defaultValue) {$/;"	f	struct:commandLine
getOptionIntValue	./tutorial/parseCommandLine.h	/^  int getOptionIntValue(string option, int defaultValue) {$/;"	f	struct:commandLine
getOptionIntValue	./utils/parseCommandLine.h	/^  int getOptionIntValue(string option, int defaultValue) {$/;"	f	struct:commandLine
getOptionLongValue	./apps/parseCommandLine.h	/^  long getOptionLongValue(string option, long defaultValue) {$/;"	f	struct:commandLine
getOptionLongValue	./ligra/parseCommandLine.h	/^  long getOptionLongValue(string option, long defaultValue) {$/;"	f	struct:commandLine
getOptionLongValue	./tutorial/parseCommandLine.h	/^  long getOptionLongValue(string option, long defaultValue) {$/;"	f	struct:commandLine
getOptionLongValue	./utils/parseCommandLine.h	/^  long getOptionLongValue(string option, long defaultValue) {$/;"	f	struct:commandLine
getOptionValue	./apps/parseCommandLine.h	/^  char* getOptionValue(string option) {$/;"	f	struct:commandLine
getOptionValue	./apps/parseCommandLine.h	/^  string getOptionValue(string option, string defaultValue) {$/;"	f	struct:commandLine
getOptionValue	./ligra/parseCommandLine.h	/^  char* getOptionValue(string option) {$/;"	f	struct:commandLine
getOptionValue	./ligra/parseCommandLine.h	/^  string getOptionValue(string option, string defaultValue) {$/;"	f	struct:commandLine
getOptionValue	./tutorial/parseCommandLine.h	/^  char* getOptionValue(string option) {$/;"	f	struct:commandLine
getOptionValue	./tutorial/parseCommandLine.h	/^  string getOptionValue(string option, string defaultValue) {$/;"	f	struct:commandLine
getOptionValue	./utils/parseCommandLine.h	/^  char* getOptionValue(string option) {$/;"	f	struct:commandLine
getOptionValue	./utils/parseCommandLine.h	/^  string getOptionValue(string option, string defaultValue) {$/;"	f	struct:commandLine
getOutDegree	./apps/compressedVertex.h	/^  uintT getOutDegree() { return degree; }$/;"	f	struct:compressedSymmetricVertex
getOutDegree	./apps/compressedVertex.h	/^  uintT getOutDegree() { return outDegree; }$/;"	f	struct:compressedAsymmetricVertex
getOutDegree	./apps/vertex.h	/^  uintT getOutDegree() { return degree; }$/;"	f	struct:symmetricVertex
getOutDegree	./apps/vertex.h	/^  uintT getOutDegree() { return outDegree; }$/;"	f	struct:asymmetricVertex
getOutDegree	./ligra/compressedVertex.h	/^  uintT getOutDegree() { return degree; }$/;"	f	struct:compressedSymmetricVertex
getOutDegree	./ligra/compressedVertex.h	/^  uintT getOutDegree() { return outDegree; }$/;"	f	struct:compressedAsymmetricVertex
getOutDegree	./ligra/vertex.h	/^  uintT getOutDegree() { return degree; }$/;"	f	struct:symmetricVertex
getOutDegree	./ligra/vertex.h	/^  uintT getOutDegree() { return outDegree; }$/;"	f	struct:asymmetricVertex
getOutDegree	./tutorial/compressedVertex.h	/^  uintT getOutDegree() { return degree; }$/;"	f	struct:compressedSymmetricVertex
getOutDegree	./tutorial/compressedVertex.h	/^  uintT getOutDegree() { return outDegree; }$/;"	f	struct:compressedAsymmetricVertex
getOutDegree	./tutorial/vertex.h	/^  uintT getOutDegree() { return degree; }$/;"	f	struct:symmetricVertex
getOutDegree	./tutorial/vertex.h	/^  uintT getOutDegree() { return outDegree; }$/;"	f	struct:asymmetricVertex
getOutNeighbor	./apps/compressedVertex.h	/^  intT getOutNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedAsymmetricVertex
getOutNeighbor	./apps/compressedVertex.h	/^  intT getOutNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedSymmetricVertex
getOutNeighbor	./apps/vertex.h	/^  intE getOutNeighbor(intT j) { return neighbors[2*j]; }$/;"	f	struct:symmetricVertex
getOutNeighbor	./apps/vertex.h	/^  intE getOutNeighbor(uintT j) { return outNeighbors[2*j]; }$/;"	f	struct:asymmetricVertex
getOutNeighbor	./apps/vertex.h	/^  uintE getOutNeighbor(uintT j) { return neighbors[j]; }$/;"	f	struct:symmetricVertex
getOutNeighbor	./apps/vertex.h	/^  uintE getOutNeighbor(uintT j) { return outNeighbors[j]; }$/;"	f	struct:asymmetricVertex
getOutNeighbor	./ligra/compressedVertex.h	/^  intT getOutNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedAsymmetricVertex
getOutNeighbor	./ligra/compressedVertex.h	/^  intT getOutNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedSymmetricVertex
getOutNeighbor	./ligra/vertex.h	/^  intE getOutNeighbor(intT j) { return neighbors[2*j]; }$/;"	f	struct:symmetricVertex
getOutNeighbor	./ligra/vertex.h	/^  intE getOutNeighbor(uintT j) { return outNeighbors[2*j]; }$/;"	f	struct:asymmetricVertex
getOutNeighbor	./ligra/vertex.h	/^  uintE getOutNeighbor(uintT j) { return neighbors[j]; }$/;"	f	struct:symmetricVertex
getOutNeighbor	./ligra/vertex.h	/^  uintE getOutNeighbor(uintT j) { return outNeighbors[j]; }$/;"	f	struct:asymmetricVertex
getOutNeighbor	./tutorial/compressedVertex.h	/^  intT getOutNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedAsymmetricVertex
getOutNeighbor	./tutorial/compressedVertex.h	/^  intT getOutNeighbor(intT j) { return -1; } \/\/should not be called$/;"	f	struct:compressedSymmetricVertex
getOutNeighbor	./tutorial/vertex.h	/^  intE getOutNeighbor(intT j) { return neighbors[2*j]; }$/;"	f	struct:symmetricVertex
getOutNeighbor	./tutorial/vertex.h	/^  intE getOutNeighbor(uintT j) { return outNeighbors[2*j]; }$/;"	f	struct:asymmetricVertex
getOutNeighbor	./tutorial/vertex.h	/^  uintE getOutNeighbor(uintT j) { return neighbors[j]; }$/;"	f	struct:symmetricVertex
getOutNeighbor	./tutorial/vertex.h	/^  uintE getOutNeighbor(uintT j) { return outNeighbors[j]; }$/;"	f	struct:asymmetricVertex
getOutNeighbors	./apps/compressedVertex.h	/^  uchar* getOutNeighbors() { return neighbors; }$/;"	f	struct:compressedSymmetricVertex
getOutNeighbors	./apps/compressedVertex.h	/^  uchar* getOutNeighbors() { return outNeighbors; }$/;"	f	struct:compressedAsymmetricVertex
getOutNeighbors	./apps/vertex.h	/^  intE* getOutNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getOutNeighbors	./apps/vertex.h	/^  intE* getOutNeighbors () { return outNeighbors; }$/;"	f	struct:asymmetricVertex
getOutNeighbors	./apps/vertex.h	/^  uintE* getOutNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getOutNeighbors	./apps/vertex.h	/^  uintE* getOutNeighbors () { return outNeighbors; }$/;"	f	struct:asymmetricVertex
getOutNeighbors	./ligra/compressedVertex.h	/^  uchar* getOutNeighbors() { return neighbors; }$/;"	f	struct:compressedSymmetricVertex
getOutNeighbors	./ligra/compressedVertex.h	/^  uchar* getOutNeighbors() { return outNeighbors; }$/;"	f	struct:compressedAsymmetricVertex
getOutNeighbors	./ligra/vertex.h	/^  intE* getOutNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getOutNeighbors	./ligra/vertex.h	/^  intE* getOutNeighbors () { return outNeighbors; }$/;"	f	struct:asymmetricVertex
getOutNeighbors	./ligra/vertex.h	/^  uintE* getOutNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getOutNeighbors	./ligra/vertex.h	/^  uintE* getOutNeighbors () { return outNeighbors; }$/;"	f	struct:asymmetricVertex
getOutNeighbors	./tutorial/compressedVertex.h	/^  uchar* getOutNeighbors() { return neighbors; }$/;"	f	struct:compressedSymmetricVertex
getOutNeighbors	./tutorial/compressedVertex.h	/^  uchar* getOutNeighbors() { return outNeighbors; }$/;"	f	struct:compressedAsymmetricVertex
getOutNeighbors	./tutorial/vertex.h	/^  intE* getOutNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getOutNeighbors	./tutorial/vertex.h	/^  intE* getOutNeighbors () { return outNeighbors; }$/;"	f	struct:asymmetricVertex
getOutNeighbors	./tutorial/vertex.h	/^  uintE* getOutNeighbors () { return neighbors; }$/;"	f	struct:symmetricVertex
getOutNeighbors	./tutorial/vertex.h	/^  uintE* getOutNeighbors () { return outNeighbors; }$/;"	f	struct:asymmetricVertex
getOutWeight	./apps/vertex.h	/^  intE getOutWeight(intT j) { return neighbors[2*j+1]; }$/;"	f	struct:symmetricVertex
getOutWeight	./apps/vertex.h	/^  intE getOutWeight(uintT j) { return outNeighbors[2*j+1]; }$/;"	f	struct:asymmetricVertex
getOutWeight	./ligra/vertex.h	/^  intE getOutWeight(intT j) { return neighbors[2*j+1]; }$/;"	f	struct:symmetricVertex
getOutWeight	./ligra/vertex.h	/^  intE getOutWeight(uintT j) { return outNeighbors[2*j+1]; }$/;"	f	struct:asymmetricVertex
getOutWeight	./tutorial/vertex.h	/^  intE getOutWeight(intT j) { return neighbors[2*j+1]; }$/;"	f	struct:symmetricVertex
getOutWeight	./tutorial/vertex.h	/^  intE getOutWeight(uintT j) { return outNeighbors[2*j+1]; }$/;"	f	struct:asymmetricVertex
getTime	./apps/gettime.h	/^  double getTime() {$/;"	f	struct:timer
getTime	./ligra/gettime.h	/^  double getTime() {$/;"	f	struct:timer
getTime	./tutorial/gettime.h	/^  double getTime() {$/;"	f	struct:timer
getWorkers	./apps/parallel.h	/^static int getWorkers() { return 1; }$/;"	f
getWorkers	./apps/parallel.h	/^static int getWorkers() { return omp_get_max_threads(); }$/;"	f
getWorkers	./apps/parallel.h	/^static int getWorkers() {$/;"	f
getWorkers	./ligra/parallel.h	/^static int getWorkers() { return 1; }$/;"	f
getWorkers	./ligra/parallel.h	/^static int getWorkers() { return omp_get_max_threads(); }$/;"	f
getWorkers	./ligra/parallel.h	/^static int getWorkers() {$/;"	f
getWorkers	./tutorial/parallel.h	/^static int getWorkers() { return 1; }$/;"	f
getWorkers	./tutorial/parallel.h	/^static int getWorkers() { return omp_get_max_threads(); }$/;"	f
getWorkers	./tutorial/parallel.h	/^static int getWorkers() {$/;"	f
getWorkers	./utils/parallel.h	/^static int getWorkers() { return 1; }$/;"	f
getWorkers	./utils/parallel.h	/^static int getWorkers() { return omp_get_max_threads(); }$/;"	f
getWorkers	./utils/parallel.h	/^static int getWorkers() {$/;"	f
getuF	./utils/graphIO.h	/^struct getuF {intT operator() (edge<intT> e) {return e.u;} };$/;"	s
graph	./apps/graph.h	/^graph(vertex* VV, long nn, long mm, Deletable* DD) : V(VV), n(nn), m(mm), D(DD), flags(NULL), transposed(0) {}$/;"	f	struct:graph
graph	./apps/graph.h	/^graph(vertex* VV, long nn, long mm, Deletable* DD, uintE* _flags) : V(VV), n(nn), m(mm), D(DD), flags(_flags), transposed(0) {}$/;"	f	struct:graph
graph	./apps/graph.h	/^struct graph {$/;"	s
graph	./ligra/graph.h	/^graph(vertex* VV, long nn, long mm, Deletable* DD) : V(VV), n(nn), m(mm), D(DD), flags(NULL), transposed(0) {}$/;"	f	struct:graph
graph	./ligra/graph.h	/^graph(vertex* VV, long nn, long mm, Deletable* DD, uintE* _flags) : V(VV), n(nn), m(mm), D(DD), flags(_flags), transposed(0) {}$/;"	f	struct:graph
graph	./ligra/graph.h	/^struct graph {$/;"	s
graph	./tutorial/graph.h	/^graph(vertex* VV, long nn, long mm, Deletable* DD) : V(VV), n(nn), m(mm), D(DD), flags(NULL), transposed(0) {}$/;"	f	struct:graph
graph	./tutorial/graph.h	/^graph(vertex* VV, long nn, long mm, Deletable* DD, uintE* _flags) : V(VV), n(nn), m(mm), D(DD), flags(_flags), transposed(0) {}$/;"	f	struct:graph
graph	./tutorial/graph.h	/^struct graph {$/;"	s
graph	./utils/graphIO.h	/^  graph(vertex<intT>* VV, intT nn, uintT mm) $/;"	f	struct:graph
graph	./utils/graphIO.h	/^  graph(vertex<intT>* VV, intT nn, uintT mm, intT* ai) $/;"	f	struct:graph
graph	./utils/graphIO.h	/^struct graph {$/;"	s
graphFromEdges	./utils/graphIO.h	/^graph<intT> graphFromEdges(edgeArray<intT> EA, bool makeSym) {$/;"	f
h	./utils/rMatGraph.C	/^  uintT h;$/;"	m	struct:rMat	file:
hashDouble	./utils/rMatGraph.C	/^double hashDouble(intT i) {$/;"	f
hashInt	./apps/utils.h	/^inline uint hashInt(uint a) {$/;"	f
hashInt	./apps/utils.h	/^inline ulong hashInt(ulong a) {$/;"	f
hashInt	./ligra/utils.h	/^inline uint hashInt(uint a) {$/;"	f
hashInt	./ligra/utils.h	/^inline ulong hashInt(ulong a) {$/;"	f
hashInt	./tutorial/utils.h	/^inline uint hashInt(uint a) {$/;"	f
hashInt	./tutorial/utils.h	/^inline ulong hashInt(ulong a) {$/;"	f
hashInt	./utils/utils.h	/^inline uint hashInt(uint a) {$/;"	f
hashInt	./utils/utils.h	/^inline ulong hashInt(ulong a) {$/;"	f
hashPair	./apps/localAlg/HeatKernel-Serial.C	/^class hashPair {$/;"	c	file:
hashToRange	./apps/localAlg/sparseSet.h	/^  inline uintT hashToRange(uintT h) {return h & mask;}$/;"	f	class:sparseAdditiveSet
iSort	./apps/blockRadixSort.h	/^  void iSort(E *A, long n, long m, Func f) { $/;"	f	namespace:intSort
iSort	./apps/blockRadixSort.h	/^  void iSort(E *A, long n, long m, char* s, Func f) { $/;"	f	namespace:intSort
iSort	./apps/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, F f) {$/;"	f	namespace:intSort
iSort	./apps/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
iSort	./apps/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, F f) {$/;"	f	namespace:intSort
iSort	./ligra/blockRadixSort.h	/^  void iSort(E *A, long n, long m, Func f) { $/;"	f	namespace:intSort
iSort	./ligra/blockRadixSort.h	/^  void iSort(E *A, long n, long m, char* s, Func f) { $/;"	f	namespace:intSort
iSort	./ligra/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, F f) {$/;"	f	namespace:intSort
iSort	./ligra/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
iSort	./ligra/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, F f) {$/;"	f	namespace:intSort
iSort	./tutorial/blockRadixSort.h	/^  void iSort(E *A, long n, long m, Func f) { $/;"	f	namespace:intSort
iSort	./tutorial/blockRadixSort.h	/^  void iSort(E *A, long n, long m, char* s, Func f) { $/;"	f	namespace:intSort
iSort	./tutorial/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, F f) {$/;"	f	namespace:intSort
iSort	./tutorial/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
iSort	./tutorial/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, F f) {$/;"	f	namespace:intSort
iSort	./utils/blockRadixSort.h	/^  void iSort(E *A, long n, long m, Func f) { $/;"	f	namespace:intSort
iSort	./utils/blockRadixSort.h	/^  void iSort(E *A, long n, long m, char* s, Func f) { $/;"	f	namespace:intSort
iSort	./utils/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, F f) {$/;"	f	namespace:intSort
iSort	./utils/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
iSort	./utils/blockRadixSort.h	/^  void iSort(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, F f) {$/;"	f	namespace:intSort
iSortBottomUp	./apps/blockRadixSort.h	/^  void iSortBottomUp(E *A, long n, long m, F f) {$/;"	f	namespace:intSort
iSortBottomUp	./ligra/blockRadixSort.h	/^  void iSortBottomUp(E *A, long n, long m, F f) {$/;"	f	namespace:intSort
iSortBottomUp	./tutorial/blockRadixSort.h	/^  void iSortBottomUp(E *A, long n, long m, F f) {$/;"	f	namespace:intSort
iSortBottomUp	./utils/blockRadixSort.h	/^  void iSortBottomUp(E *A, long n, long m, F f) {$/;"	f	namespace:intSort
iSortSpace	./apps/blockRadixSort.h	/^  long iSortSpace(long n) {$/;"	f	namespace:intSort
iSortSpace	./ligra/blockRadixSort.h	/^  long iSortSpace(long n) {$/;"	f	namespace:intSort
iSortSpace	./tutorial/blockRadixSort.h	/^  long iSortSpace(long n) {$/;"	f	namespace:intSort
iSortSpace	./utils/blockRadixSort.h	/^  long iSortSpace(long n) {$/;"	f	namespace:intSort
iSortX	./apps/blockRadixSort.h	/^  void iSortX(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
iSortX	./ligra/blockRadixSort.h	/^  void iSortX(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
iSortX	./tutorial/blockRadixSort.h	/^  void iSortX(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
iSortX	./utils/blockRadixSort.h	/^  void iSortX(E *A, oint* bucketOffsets, long n, long m, bool bottomUp, $/;"	f	namespace:intSort
identityF	./apps/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	s
identityF	./ligra/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	s
identityF	./tutorial/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	s
identityF	./utils/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	s
inDegree	./apps/compressedVertex.h	/^  uintT inDegree;$/;"	m	struct:compressedAsymmetricVertex
inDegree	./apps/vertex.h	/^  uintT inDegree;$/;"	m	struct:asymmetricVertex
inDegree	./ligra/compressedVertex.h	/^  uintT inDegree;$/;"	m	struct:compressedAsymmetricVertex
inDegree	./ligra/vertex.h	/^  uintT inDegree;$/;"	m	struct:asymmetricVertex
inDegree	./tutorial/compressedVertex.h	/^  uintT inDegree;$/;"	m	struct:compressedAsymmetricVertex
inDegree	./tutorial/vertex.h	/^  uintT inDegree;$/;"	m	struct:asymmetricVertex
inDegrees	./apps/IO.h	/^  uintE* inDegrees;$/;"	m	struct:Compressed_Mem
inDegrees	./ligra/IO.h	/^  uintE* inDegrees;$/;"	m	struct:Compressed_Mem
inDegrees	./tutorial/IO.h	/^  uintE* inDegrees;$/;"	m	struct:Compressed_Mem
inEdges	./apps/IO.h	/^  uchar* inEdges;$/;"	m	struct:Compressed_Mem
inEdges	./apps/IO.h	/^  void* allocatedInplace, * inEdges;$/;"	m	struct:Uncompressed_Mem
inEdges	./ligra/IO.h	/^  uchar* inEdges;$/;"	m	struct:Compressed_Mem
inEdges	./ligra/IO.h	/^  void* allocatedInplace, * inEdges;$/;"	m	struct:Uncompressed_Mem
inEdges	./tutorial/IO.h	/^  uchar* inEdges;$/;"	m	struct:Compressed_Mem
inEdges	./tutorial/IO.h	/^  void* allocatedInplace, * inEdges;$/;"	m	struct:Uncompressed_Mem
inNeighbors	./apps/compressedVertex.h	/^  uchar* inNeighbors;$/;"	m	struct:compressedAsymmetricVertex
inNeighbors	./apps/vertex.h	/^  uintE* inNeighbors, *outNeighbors;$/;"	m	struct:asymmetricVertex
inNeighbors	./ligra/compressedVertex.h	/^  uchar* inNeighbors;$/;"	m	struct:compressedAsymmetricVertex
inNeighbors	./ligra/vertex.h	/^  uintE* inNeighbors, *outNeighbors;$/;"	m	struct:asymmetricVertex
inNeighbors	./tutorial/compressedVertex.h	/^  uchar* inNeighbors;$/;"	m	struct:compressedAsymmetricVertex
inNeighbors	./tutorial/vertex.h	/^  uintE* inNeighbors, *outNeighbors;$/;"	m	struct:asymmetricVertex
inOffsets	./apps/IO.h	/^  uintT* inOffsets;$/;"	m	struct:Compressed_Mem
inOffsets	./ligra/IO.h	/^  uintT* inOffsets;$/;"	m	struct:Compressed_Mem
inOffsets	./tutorial/IO.h	/^  uintT* inOffsets;$/;"	m	struct:Compressed_Mem
incrementIndex	./apps/localAlg/sparseSet.h	/^  inline uintT incrementIndex(uintT h) {return hashToRange(h+1);}$/;"	f	class:sparseAdditiveSet
initF	./apps/Triangle.C	/^  initF(vertex* _V, long* _counts) : V(_V), counts(_counts) {}$/;"	f	struct:initF
initF	./apps/Triangle.C	/^struct initF { \/\/for vertexMap to initial counts and sort neighbors for merging$/;"	s	file:
insert	./apps/localAlg/sparseSet.h	/^  bool insert(kvPair v) {$/;"	f	class:sparseAdditiveSet
insertionSort	./apps/quickSort.h	/^void insertionSort(E* A, intT n, BinPred f) {$/;"	f
insertionSort	./ligra/quickSort.h	/^void insertionSort(E* A, intT n, BinPred f) {$/;"	f
insertionSort	./tutorial/quickSort.h	/^void insertionSort(E* A, intT n, BinPred f) {$/;"	f
insertionSort	./utils/quickSort.h	/^void insertionSort(E* A, intT n, BinPred f) {$/;"	f
intE	./apps/parallel.h	/^typedef int intE;$/;"	t
intE	./apps/parallel.h	/^typedef long intE;$/;"	t
intE	./ligra/parallel.h	/^typedef int intE;$/;"	t
intE	./ligra/parallel.h	/^typedef long intE;$/;"	t
intE	./tutorial/parallel.h	/^typedef int intE;$/;"	t
intE	./tutorial/parallel.h	/^typedef long intE;$/;"	t
intE	./utils/parallel.h	/^typedef int intE;$/;"	t
intE	./utils/parallel.h	/^typedef long intE;$/;"	t
intEPair	./apps/byte-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./apps/byte.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./apps/byteRLE-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./apps/byteRLE.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./apps/nibble-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./apps/nibble.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./ligra/byte-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./ligra/byte.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./ligra/byteRLE-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./ligra/byteRLE.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./ligra/nibble-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./ligra/nibble.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./tutorial/byte-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./tutorial/byte.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./tutorial/byteRLE-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./tutorial/byteRLE.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./tutorial/nibble-pd.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intEPair	./tutorial/nibble.h	/^typedef pair<uintE,intE> intEPair;$/;"	t
intLT	./apps/Triangle.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	s	file:
intLT	./apps/localAlg/ACL-Sync-Local-Opt.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	s	file:
intLT	./apps/localAlg/ACL-Sync-Local.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	s	file:
intLT	./apps/localAlg/HeatKernel-Parallel.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	s	file:
intLT	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	s	file:
intPair	./apps/IO.h	/^typedef pair<uintE,uintE> intPair;$/;"	t
intPair	./apps/eccentricity/CLRSTV.C	/^typedef pair<uintE,uintE> intPair;$/;"	t	file:
intPair	./apps/eccentricity/RV.C	/^typedef pair<uintE,uintE> intPair;$/;"	t	file:
intPair	./apps/eccentricity/Simple-Approx-Ecc.C	/^typedef pair<uintE,uintE> intPair;$/;"	t	file:
intPair	./apps/eccentricity/TK.C	/^typedef pair<uintE,uintE> intPair;$/;"	t	file:
intPair	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^typedef pair<uintE,uintE> intPair;$/;"	t	file:
intPair	./apps/eccentricity/kBFS-Ecc.C	/^typedef pair<uintE,uintE> intPair;$/;"	t	file:
intPair	./ligra/IO.h	/^typedef pair<uintE,uintE> intPair;$/;"	t
intPair	./tutorial/IO.h	/^typedef pair<uintE,uintE> intPair;$/;"	t
intSort	./apps/blockRadixSort.h	/^namespace intSort {$/;"	n
intSort	./ligra/blockRadixSort.h	/^namespace intSort {$/;"	n
intSort	./tutorial/blockRadixSort.h	/^namespace intSort {$/;"	n
intSort	./utils/blockRadixSort.h	/^namespace intSort {$/;"	n
intT	./apps/parallel.h	/^typedef int intT;$/;"	t
intT	./apps/parallel.h	/^typedef long intT;$/;"	t
intT	./ligra/parallel.h	/^typedef int intT;$/;"	t
intT	./ligra/parallel.h	/^typedef long intT;$/;"	t
intT	./tutorial/parallel.h	/^typedef int intT;$/;"	t
intT	./tutorial/parallel.h	/^typedef long intT;$/;"	t
intT	./utils/parallel.h	/^typedef int intT;$/;"	t
intT	./utils/parallel.h	/^typedef long intT;$/;"	t
intTriple	./apps/IO.h	/^typedef pair<uintE, pair<uintE,intE> > intTriple;$/;"	t
intTriple	./ligra/IO.h	/^typedef pair<uintE, pair<uintE,intE> > intTriple;$/;"	t
intTriple	./tutorial/IO.h	/^typedef pair<uintE, pair<uintE,intE> > intTriple;$/;"	t
intTriple2	./apps/encoder.C	/^typedef pair<pair<uintE,uintE> ,uintE > intTriple2;$/;"	t	file:
intTriple2	./ligra/encoder.C	/^typedef pair<pair<uintE,uintE> ,uintE > intTriple2;$/;"	t	file:
intTriple2	./tutorial/encoder.C	/^typedef pair<pair<uintE,uintE> ,uintE > intTriple2;$/;"	t	file:
integerSort	./apps/blockRadixSort.h	/^static void integerSort(uintT *A, long n) {$/;"	f
integerSort	./apps/blockRadixSort.h	/^static void integerSort(uintT *A, long n, char* s) {$/;"	f
integerSort	./apps/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n) {$/;"	f
integerSort	./apps/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n, char* s) {$/;"	f
integerSort	./ligra/blockRadixSort.h	/^static void integerSort(uintT *A, long n) {$/;"	f
integerSort	./ligra/blockRadixSort.h	/^static void integerSort(uintT *A, long n, char* s) {$/;"	f
integerSort	./ligra/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n) {$/;"	f
integerSort	./ligra/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n, char* s) {$/;"	f
integerSort	./tutorial/blockRadixSort.h	/^static void integerSort(uintT *A, long n) {$/;"	f
integerSort	./tutorial/blockRadixSort.h	/^static void integerSort(uintT *A, long n, char* s) {$/;"	f
integerSort	./tutorial/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n) {$/;"	f
integerSort	./tutorial/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n, char* s) {$/;"	f
integerSort	./utils/blockRadixSort.h	/^static void integerSort(uintT *A, long n) {$/;"	f
integerSort	./utils/blockRadixSort.h	/^static void integerSort(uintT *A, long n, char* s) {$/;"	f
integerSort	./utils/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n) {$/;"	f
integerSort	./utils/blockRadixSort.h	/^void integerSort(pair<uintT,T> *A, long n, char* s) {$/;"	f
inverseNumPaths	./apps/BC.C	/^  fType* Dependencies, *inverseNumPaths;$/;"	m	struct:BC_Back_Vertex_F	file:
isDense	./apps/vertexSubset.h	/^  bool isDense;$/;"	m	struct:vertexSubset
isDense	./ligra/vertexSubset.h	/^  bool isDense;$/;"	m	struct:vertexSubset
isDense	./tutorial/vertexSubset.h	/^  bool isDense;$/;"	m	struct:vertexSubset
isEmpty	./apps/vertexSubset.h	/^  bool isEmpty() { return m==0; }$/;"	f	struct:vertexSubset
isEmpty	./ligra/vertexSubset.h	/^  bool isEmpty() { return m==0; }$/;"	f	struct:vertexSubset
isEmpty	./tutorial/vertexSubset.h	/^  bool isEmpty() { return m==0; }$/;"	f	struct:vertexSubset
isSpace	./apps/IO.h	/^inline bool isSpace(char c) {$/;"	f
isSpace	./ligra/IO.h	/^inline bool isSpace(char c) {$/;"	f
isSpace	./tutorial/IO.h	/^inline bool isSpace(char c) {$/;"	f
isSpace	./utils/graphIO.h	/^  inline bool isSpace(char c) {$/;"	f	namespace:benchIO
k	./apps/KCore.C	/^  uintE k;$/;"	m	struct:Deg_AtLeast_K	file:
k	./apps/KCore.C	/^  uintE k;$/;"	m	struct:Deg_LessThan_K	file:
k	./tutorial/KCore.C	/^  long k;$/;"	m	struct:Deg_AtLeast_K	file:
k	./tutorial/KCore.C	/^  long k;$/;"	m	struct:Deg_LessThan_K	file:
kvPair	./apps/localAlg/sparseSet.h	/^  typedef pair<uintE,E> kvPair;$/;"	t	class:sparseAdditiveSet
label	./apps/BFSCC.C	/^  uintE label;$/;"	m	struct:BFS_F	file:
label	./apps/eccentricity/CCBFS.h	/^  intE label;$/;"	m	struct:CCBFS_F
lambda	./apps/CF.C	/^  double step, lambda;$/;"	m	struct:CF_Vertex_F	file:
lastTime	./apps/gettime.h	/^  double lastTime;$/;"	m	struct:timer
lastTime	./ligra/gettime.h	/^  double lastTime;$/;"	m	struct:timer
lastTime	./tutorial/gettime.h	/^  double lastTime;$/;"	m	struct:timer
latent_curr	./apps/CF.C	/^  double *latent_curr, *error;$/;"	m	struct:CF_Vertex_F	file:
latent_curr	./apps/CF.C	/^  double* latent_curr, *error;$/;"	m	struct:CF_Edge_F	file:
length	./apps/eccentricity/FM-Ecc.C	/^  long length;$/;"	m	struct:Ecc_F	file:
length	./apps/eccentricity/FM-Ecc.C	/^  long length;$/;"	m	struct:Ecc_Vertex_F	file:
length	./apps/eccentricity/LogLog-Ecc.C	/^  long length;$/;"	m	struct:Ecc_F	file:
length	./apps/eccentricity/LogLog-Ecc.C	/^  long length;$/;"	m	struct:Ecc_Vertex_F	file:
length	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  const long length;$/;"	m	struct:Ecc_F	file:
length	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  const long length;$/;"	m	struct:Ecc_Vertex_F	file:
length	./apps/eccentricity/kBFS-Ecc.C	/^  const long length;$/;"	m	struct:Ecc_F	file:
length	./apps/eccentricity/kBFS-Ecc.C	/^  const long length;$/;"	m	struct:Ecc_Vertex_F	file:
length	./apps/eccentricity/kBFS-Exact.C	/^  long length;$/;"	m	struct:Ecc_F	file:
length	./apps/eccentricity/kBFS-Exact.C	/^  long length;$/;"	m	struct:Ecc_Vertex_F	file:
loadFactor	./apps/localAlg/sparseSet.h	/^  float loadFactor;$/;"	m	class:sparseAdditiveSet
loc2d	./utils/gridGraph.C	/^intT loc2d(intT n, intT i1, intT i2) {$/;"	f
loc3d	./utils/gridGraph.C	/^intT loc3d(intT n, intT i1, intT i2, intT i3) {$/;"	f
log2RoundUp	./apps/localAlg/sparseSet.h	/^static int log2RoundUp(T i) {$/;"	f
log2Up	./apps/blockRadixSort.h	/^static int log2Up(T i) {$/;"	f
log2Up	./ligra/blockRadixSort.h	/^static int log2Up(T i) {$/;"	f
log2Up	./tutorial/blockRadixSort.h	/^static int log2Up(T i) {$/;"	f
log2Up	./utils/blockRadixSort.h	/^static int log2Up(T i) {$/;"	f
logCost	./apps/encoder.C	/^void logCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){$/;"	f
logCost	./ligra/encoder.C	/^void logCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){$/;"	f
logCost	./tutorial/encoder.C	/^void logCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){$/;"	f
lower	./apps/eccentricity/Simple-Approx-Ecc.C	/^  uintE* lower;$/;"	m	struct:min_lower	file:
lower	./apps/eccentricity/TK.C	/^  uintE* lower;$/;"	m	struct:min_lower	file:
m	./apps/IO.h	/^  long m; \/\/ number of substrings$/;"	m	struct:words
m	./apps/IO.h	/^  long m;$/;"	m	struct:Compressed_Mem
m	./apps/IO.h	/^  long m;$/;"	m	struct:Uncompressed_Mem
m	./apps/graph.h	/^  long m;$/;"	m	struct:graph
m	./apps/localAlg/sparseSet.h	/^  uintT m;$/;"	m	class:sparseAdditiveSet
m	./apps/vertexSubset.h	/^  long n, m;$/;"	m	struct:vertexSubset
m	./ligra/IO.h	/^  long m; \/\/ number of substrings$/;"	m	struct:words
m	./ligra/IO.h	/^  long m;$/;"	m	struct:Compressed_Mem
m	./ligra/IO.h	/^  long m;$/;"	m	struct:Uncompressed_Mem
m	./ligra/graph.h	/^  long m;$/;"	m	struct:graph
m	./ligra/vertexSubset.h	/^  long n, m;$/;"	m	struct:vertexSubset
m	./tutorial/IO.h	/^  long m; \/\/ number of substrings$/;"	m	struct:words
m	./tutorial/IO.h	/^  long m;$/;"	m	struct:Compressed_Mem
m	./tutorial/IO.h	/^  long m;$/;"	m	struct:Uncompressed_Mem
m	./tutorial/graph.h	/^  long m;$/;"	m	struct:graph
m	./tutorial/vertexSubset.h	/^  long n, m;$/;"	m	struct:vertexSubset
m	./utils/graphIO.h	/^    long m; \/\/ number of substrings$/;"	m	struct:benchIO::words
m	./utils/graphIO.h	/^  intT m;$/;"	m	struct:graph
m	./utils/graphIO.h	/^  uintT m;$/;"	m	struct:wghGraph
makeSymmetric	./utils/graphIO.h	/^edgeArray<intT> makeSymmetric(edgeArray<intT> A) {$/;"	f
map	./apps/localAlg/sparseSet.h	/^  void map(F f){ $/;"	f	class:sparseAdditiveSet
mapIndex	./apps/localAlg/sparseSet.h	/^  void mapIndex(F f){ $/;"	f	class:sparseAdditiveSet
mapReduce	./apps/utils.h	/^  OT mapReduce(IT* A, intT n, F f, G g) {$/;"	f	namespace:sequence
mapReduce	./ligra/utils.h	/^  OT mapReduce(IT* A, intT n, F f, G g) {$/;"	f	namespace:sequence
mapReduce	./tutorial/utils.h	/^  OT mapReduce(IT* A, intT n, F f, G g) {$/;"	f	namespace:sequence
mapReduce	./utils/utils.h	/^  OT mapReduce(IT* A, intT n, F f, G g) {$/;"	f	namespace:sequence
mask	./apps/eccentricity/LogLog-Ecc.C	40;"	d	file:
mask	./apps/localAlg/sparseSet.h	/^  intT mask;$/;"	m	class:sparseAdditiveSet
maxF	./apps/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	s
maxF	./ligra/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	s
maxF	./tutorial/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	s
maxF	./utils/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	s
maxFirstF	./apps/eccentricity/CLRSTV.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	s	file:
maxFirstF	./apps/eccentricity/RV.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	s	file:
maxFirstF	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	s	file:
maxFirstF	./apps/eccentricity/kBFS-Ecc.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	s	file:
max_upper	./apps/eccentricity/Simple-Approx-Ecc.C	/^  max_upper(uintE* _upper) : upper(_upper) {}$/;"	f	struct:max_upper
max_upper	./apps/eccentricity/Simple-Approx-Ecc.C	/^struct max_upper {$/;"	s	file:
max_upper	./apps/eccentricity/TK.C	/^  max_upper(uintE* _upper) : upper(_upper) {}$/;"	f	struct:max_upper
max_upper	./apps/eccentricity/TK.C	/^struct max_upper {$/;"	s	file:
maxdeg	./apps/MaxDegree.C	/^    uintE maxdeg;$/;"	m	struct:MAXDEG_F	file:
median	./apps/quickSort.h	/^E median(E a, E b, E c, BinPred f) {$/;"	f
median	./ligra/quickSort.h	/^E median(E a, E b, E c, BinPred f) {$/;"	f
median	./tutorial/quickSort.h	/^E median(E a, E b, E c, BinPred f) {$/;"	f
median	./utils/quickSort.h	/^E median(E a, E b, E c, BinPred f) {$/;"	f
mergeSeq	./apps/localAlg/sampleSort.h	/^void mergeSeq (E* sA, E* sB, intT* sC, intT lA, intT lB, BinPred f) {$/;"	f
minDiPair	./apps/localAlg/sweep.h	/^struct minDiPair { diPair operator() (diPair a, diPair b){$/;"	s
minF	./apps/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	s
minF	./ligra/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	s
minF	./tutorial/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	s
minF	./utils/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	s
min_lower	./apps/eccentricity/Simple-Approx-Ecc.C	/^  min_lower(uintE* _lower) : lower(_lower) {}$/;"	f	struct:min_lower
min_lower	./apps/eccentricity/Simple-Approx-Ecc.C	/^struct min_lower {$/;"	s	file:
min_lower	./apps/eccentricity/TK.C	/^  min_lower(uintE* _lower) : lower(_lower) {}$/;"	f	struct:min_lower
min_lower	./apps/eccentricity/TK.C	/^struct min_lower {$/;"	s	file:
n	./apps/IO.h	/^  long n; \/\/ total number of characters$/;"	m	struct:words
n	./apps/IO.h	/^  long n;$/;"	m	struct:Compressed_Mem
n	./apps/IO.h	/^  long n;$/;"	m	struct:Uncompressed_Mem
n	./apps/graph.h	/^  long n;$/;"	m	struct:graph
n	./apps/utils.h	/^  long n;$/;"	m	struct:_seq
n	./apps/vertexSubset.h	/^  long n, m;$/;"	m	struct:vertexSubset
n	./ligra/IO.h	/^  long n; \/\/ total number of characters$/;"	m	struct:words
n	./ligra/IO.h	/^  long n;$/;"	m	struct:Compressed_Mem
n	./ligra/IO.h	/^  long n;$/;"	m	struct:Uncompressed_Mem
n	./ligra/graph.h	/^  long n;$/;"	m	struct:graph
n	./ligra/utils.h	/^  long n;$/;"	m	struct:_seq
n	./ligra/vertexSubset.h	/^  long n, m;$/;"	m	struct:vertexSubset
n	./tutorial/IO.h	/^  long n; \/\/ total number of characters$/;"	m	struct:words
n	./tutorial/IO.h	/^  long n;$/;"	m	struct:Compressed_Mem
n	./tutorial/IO.h	/^  long n;$/;"	m	struct:Uncompressed_Mem
n	./tutorial/graph.h	/^  long n;$/;"	m	struct:graph
n	./tutorial/utils.h	/^  long n;$/;"	m	struct:_seq
n	./tutorial/vertexSubset.h	/^  long n, m;$/;"	m	struct:vertexSubset
n	./utils/graphIO.h	/^    long n; \/\/ total number of characters$/;"	m	struct:benchIO::words
n	./utils/graphIO.h	/^  intT n;$/;"	m	struct:graph
n	./utils/graphIO.h	/^  intT n;$/;"	m	struct:wghGraph
n	./utils/rMatGraph.C	/^  intT n; $/;"	m	struct:rMat	file:
n	./utils/utils.h	/^  long n;$/;"	m	struct:_seq
nEQF	./utils/graphIO.h	/^struct nEQF {bool operator() (edge<intT> e) {return (e.u != e.v);}};$/;"	s
nblocks	./apps/utils.h	101;"	d
nblocks	./ligra/utils.h	101;"	d
nblocks	./tutorial/utils.h	101;"	d
nblocks	./utils/utils.h	101;"	d
neighbors	./apps/compressedVertex.h	/^  uchar* neighbors;$/;"	m	struct:compressedSymmetricVertex
neighbors	./apps/vertex.h	/^  uintE* neighbors;$/;"	m	struct:symmetricVertex
neighbors	./ligra/compressedVertex.h	/^  uchar* neighbors;$/;"	m	struct:compressedSymmetricVertex
neighbors	./ligra/vertex.h	/^  uintE* neighbors;$/;"	m	struct:symmetricVertex
neighbors	./tutorial/compressedVertex.h	/^  uchar* neighbors;$/;"	m	struct:compressedSymmetricVertex
neighbors	./tutorial/vertex.h	/^  uintE* neighbors;$/;"	m	struct:symmetricVertex
newA	./apps/utils.h	50;"	d
newA	./ligra/utils.h	50;"	d
newA	./tutorial/utils.h	50;"	d
newA	./utils/utils.h	50;"	d
new_p	./apps/localAlg/Nibble-Parallel.C	/^  sparseAdditiveSet<float> p, new_p;$/;"	m	struct:Local_Update	file:
new_p	./apps/localAlg/Nibble-Parallel.C	/^  sparseAdditiveSet<float> p, new_p;$/;"	m	struct:Nibble_F	file:
new_r	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  sparseAdditiveSet<float> p, r, new_r;$/;"	m	struct:ACL_F	file:
new_r	./apps/localAlg/ACL-Sync-Local.C	/^  sparseAdditiveSet<float> p, r, new_r;$/;"	m	struct:ACL_F	file:
new_r	./apps/localAlg/HeatKernel-Parallel.C	/^  sparseAdditiveSet<float> x, r, new_r;$/;"	m	struct:HK_F	file:
next	./apps/gettime.h	/^  double next() {$/;"	f	struct:timer
next	./ligra/gettime.h	/^  double next() {$/;"	f	struct:timer
next	./tutorial/gettime.h	/^  double next() {$/;"	f	struct:timer
nextArr	./apps/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseForwardT
nextArr	./apps/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseT
nextArr	./ligra/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseForwardT
nextArr	./ligra/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseT
nextArr	./tutorial/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseForwardT
nextArr	./tutorial/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseT
nextTime	./apps/gettime.h	112;"	d
nextTime	./ligra/gettime.h	112;"	d
nextTime	./tutorial/gettime.h	112;"	d
nextTimeN	./apps/gettime.h	113;"	d
nextTimeN	./ligra/gettime.h	113;"	d
nextTimeN	./tutorial/gettime.h	113;"	d
nghSum	./apps/PageRankDelta.C	/^  double* Delta, *nghSum;$/;"	m	struct:PR_F	file:
nghSum	./apps/PageRankDelta.C	/^  double* nghSum;$/;"	m	struct:PR_Vertex_Reset	file:
nghSum	./apps/PageRankDelta.C	/^  double* p, *Delta, *nghSum;$/;"	m	struct:PR_Vertex_F	file:
nghSum	./apps/PageRankDelta.C	/^  double* p, *Delta, *nghSum;$/;"	m	struct:PR_Vertex_F_FirstRound	file:
nghWeights	./utils/graphIO.h	/^  intT* nghWeights;$/;"	m	struct:wghVertex
nonMaxF	./apps/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	s
nonMaxF	./ligra/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	s
nonMaxF	./tutorial/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	s
nonMaxF	./utils/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	s
nonZeros	./utils/graphIO.h	/^  intT nonZeros;$/;"	m	struct:edgeArray
notEmptyF	./apps/localAlg/sparseSet.h	/^    kvPair e; notEmptyF(kvPair _e) : e(_e) {} $/;"	f	struct:sparseAdditiveSet::notEmptyF
notEmptyF	./apps/localAlg/sparseSet.h	/^  struct notEmptyF { $/;"	s	class:sparseAdditiveSet
notMax	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^struct notMax { bool operator () (uintE a) { return a != UINT_E_MAX; }};$/;"	s	file:
notZero	./utils/graphIO.h	/^  struct notZero { bool operator() (char A) {return A > 0;}};$/;"	s	namespace:benchIO
numBytesSigned	./apps/byteRLE-pd.h	/^int numBytesSigned (intE x) {$/;"	f
numBytesSigned	./apps/byteRLE.h	/^int numBytesSigned (intE x) {$/;"	f
numBytesSigned	./ligra/byteRLE-pd.h	/^int numBytesSigned (intE x) {$/;"	f
numBytesSigned	./ligra/byteRLE.h	/^int numBytesSigned (intE x) {$/;"	f
numBytesSigned	./tutorial/byteRLE-pd.h	/^int numBytesSigned (intE x) {$/;"	f
numBytesSigned	./tutorial/byteRLE.h	/^int numBytesSigned (intE x) {$/;"	f
numCols	./utils/graphIO.h	/^  intT numCols;$/;"	m	struct:edgeArray
numNonzeros	./apps/vertexSubset.h	/^  long numNonzeros() { return m; }$/;"	f	struct:vertexSubset
numNonzeros	./ligra/vertexSubset.h	/^  long numNonzeros() { return m; }$/;"	f	struct:vertexSubset
numNonzeros	./tutorial/vertexSubset.h	/^  long numNonzeros() { return m; }$/;"	f	struct:vertexSubset
numRows	./apps/vertexSubset.h	/^  long numRows() { return n; }$/;"	f	struct:vertexSubset
numRows	./ligra/vertexSubset.h	/^  long numRows() { return n; }$/;"	f	struct:vertexSubset
numRows	./tutorial/vertexSubset.h	/^  long numRows() { return n; }$/;"	f	struct:vertexSubset
numRows	./utils/graphIO.h	/^  intT numRows;$/;"	m	struct:edgeArray
o	./apps/compressedVertex.h	/^    uintT v, o;$/;"	m	struct:decode_compressed::sparseT
o	./ligra/compressedVertex.h	/^    uintT v, o;$/;"	m	struct:decode_compressed::sparseT
o	./tutorial/compressedVertex.h	/^    uintT v, o;$/;"	m	struct:decode_compressed::sparseT
offsets	./apps/IO.h	/^  uintT* offsets;$/;"	m	struct:Compressed_Mem
offsets	./ligra/IO.h	/^  uintT* offsets;$/;"	m	struct:Compressed_Mem
offsets	./tutorial/IO.h	/^  uintT* offsets;$/;"	m	struct:Compressed_Mem
on	./apps/gettime.h	/^  bool on;$/;"	m	struct:timer
on	./ligra/gettime.h	/^  bool on;$/;"	m	struct:timer
on	./tutorial/gettime.h	/^  bool on;$/;"	m	struct:timer
oneMinusAlphaOverOnePlusAlpha	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  double oneMinusAlphaOverOnePlusAlpha;$/;"	m	struct:ACL_F	file:
oneMinusAlphaOverTwo	./apps/localAlg/ACL-Sync-Local.C	/^  double oneMinusAlphaOverTwo;$/;"	m	struct:ACL_F	file:
one_over_n	./apps/PageRankDelta.C	/^  double damping, addedConstant, one_over_n, epsilon2;$/;"	m	struct:PR_Vertex_F_FirstRound	file:
operator ()	./apps/BC.C	/^  inline bool operator() (uintE i) {$/;"	f	struct:BC_Back_Vertex_F
operator ()	./apps/BC.C	/^  inline bool operator() (uintE i) {$/;"	f	struct:BC_Vertex_F
operator ()	./apps/BellmanFord.C	/^  inline bool operator() (uintE i){$/;"	f	struct:BF_Vertex_F
operator ()	./apps/CF.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:CF_Vertex_F
operator ()	./apps/Components.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:CC_Vertex_F
operator ()	./apps/IO.h	/^  bool operator() (pair<uintE,E> a, pair<uintE,E> b) {$/;"	f	struct:pairFirstCmp
operator ()	./apps/IO.h	/^  bool operator() (pair<uintE,IntType> a, pair<uintE,IntType> b) {$/;"	f	struct:pairBothCmp
operator ()	./apps/IO.h	/^struct getFirst {uintE operator() (pair<uintE,E> a) {return a.first;} };$/;"	f	struct:getFirst
operator ()	./apps/KCore.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:Deg_AtLeast_K
operator ()	./apps/KCore.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:Deg_LessThan_K
operator ()	./apps/MIS.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:MIS_Filter
operator ()	./apps/PageRank.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:PR_Vertex_F
operator ()	./apps/PageRank.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:PR_Vertex_Reset
operator ()	./apps/PageRankDelta.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:PR_Vertex_F
operator ()	./apps/PageRankDelta.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:PR_Vertex_F_FirstRound
operator ()	./apps/PageRankDelta.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:PR_Vertex_Reset
operator ()	./apps/Radii.C	/^  inline bool operator() (uintE i) {$/;"	f	struct:Radii_Vertex_F
operator ()	./apps/Triangle.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:initF
operator ()	./apps/Triangle.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	f	struct:intLT
operator ()	./apps/blockRadixSort.h	/^      long operator() (E p) {return _mask&(_f(p)>>_offset);}$/;"	f	struct:intSort::eBits
operator ()	./apps/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	f	struct:firstF
operator ()	./apps/eccentricity/CCBFS.h	/^  inline bool operator () (const uintE &i) {$/;"	f	struct:CC_Vertex_F
operator ()	./apps/eccentricity/CLRSTV.C	/^  intE operator() (intE i) {return V[i].getOutDegree();}$/;"	f	struct:getDegree
operator ()	./apps/eccentricity/CLRSTV.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	f	struct:maxFirstF
operator ()	./apps/eccentricity/FM-Ecc.C	/^  inline bool operator() (const uintE &i) {$/;"	f	struct:Ecc_Vertex_F
operator ()	./apps/eccentricity/LogLog-Ecc.C	/^  inline bool operator() (const uintE &i) {$/;"	f	struct:Ecc_Vertex_F
operator ()	./apps/eccentricity/RV.C	/^  intE operator() (intE i) {return V[i].getOutDegree();}$/;"	f	struct:getDegree
operator ()	./apps/eccentricity/RV.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	f	struct:maxFirstF
operator ()	./apps/eccentricity/Simple-Approx-Ecc.C	/^  intE operator() (intE i) {return V[i].getOutDegree();}$/;"	f	struct:getDegree
operator ()	./apps/eccentricity/Simple-Approx-Ecc.C	/^  uintE operator() (const uintE& a, const uintE& b) {$/;"	f	struct:max_upper
operator ()	./apps/eccentricity/Simple-Approx-Ecc.C	/^  uintE operator() (const uintE& a, const uintE& b) {$/;"	f	struct:min_lower
operator ()	./apps/eccentricity/TK.C	/^  intE operator() (intE i) {return V[i].getOutDegree();}$/;"	f	struct:getDegree
operator ()	./apps/eccentricity/TK.C	/^  uintE operator() (const uintE& a, const uintE& b) {$/;"	f	struct:max_upper
operator ()	./apps/eccentricity/TK.C	/^  uintE operator() (const uintE& a, const uintE& b) {$/;"	f	struct:min_lower
operator ()	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  inline bool operator() (const uintE &i) {$/;"	f	struct:Ecc_Vertex_F
operator ()	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  intE operator() (intE i) {return V[i].getOutDegree();}$/;"	f	struct:getDegree
operator ()	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	f	struct:maxFirstF
operator ()	./apps/eccentricity/kBFS-Ecc.C	/^  inline bool operator() (const uintE &i) {$/;"	f	struct:Ecc_Vertex_F
operator ()	./apps/eccentricity/kBFS-Ecc.C	/^  intE operator() (intE i) {return V[i].getOutDegree();}$/;"	f	struct:getDegree
operator ()	./apps/eccentricity/kBFS-Ecc.C	/^struct maxFirstF { intPair operator() (const intPair& a, const intPair& b) $/;"	f	struct:maxFirstF
operator ()	./apps/eccentricity/kBFS-Exact.C	/^  inline bool operator() (const uintE &i) {$/;"	f	struct:Ecc_Vertex_F
operator ()	./apps/encoder.C	/^  bool operator() (intTriple2 a, intTriple2 b) {$/;"	f	struct:tripleCmp
operator ()	./apps/localAlg/ACL-Serial-Naive.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	f	struct:pq_compare
operator ()	./apps/localAlg/ACL-Serial-Opt-Naive.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	f	struct:pq_compare
operator ()	./apps/localAlg/ACL-Serial-Opt.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	f	struct:pq_compare
operator ()	./apps/localAlg/ACL-Serial.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	f	struct:pq_compare
operator ()	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  inline bool operator () (ACLpair val) {$/;"	f	struct:activeF
operator ()	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:Local_Update
operator ()	./apps/localAlg/ACL-Sync-Local-Opt.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	f	struct:intLT
operator ()	./apps/localAlg/ACL-Sync-Local.C	/^  inline bool operator () (ACLpair val) {$/;"	f	struct:activeF
operator ()	./apps/localAlg/ACL-Sync-Local.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:Local_Update
operator ()	./apps/localAlg/ACL-Sync-Local.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	f	struct:intLT
operator ()	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool operator () (ACLpair val) {$/;"	f	struct:activeF
operator ()	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:Local_Update
operator ()	./apps/localAlg/HeatKernel-Parallel.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	f	struct:intLT
operator ()	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^struct intLT { bool operator () (uintT a, uintT b) { return a < b; }; };$/;"	f	struct:intLT
operator ()	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^struct notMax { bool operator () (uintE a) { return a != UINT_E_MAX; }};$/;"	f	struct:notMax
operator ()	./apps/localAlg/HeatKernel-Serial.C	/^  bool operator () (const intPair &a, const intPair &b) const {$/;"	f	class:equalPair
operator ()	./apps/localAlg/HeatKernel-Serial.C	/^  size_t operator () (const intPair &x) const {$/;"	f	class:hashPair
operator ()	./apps/localAlg/Nibble-Parallel.C	/^  inline bool operator () (ACLpair val) {$/;"	f	struct:activeF
operator ()	./apps/localAlg/Nibble-Parallel.C	/^  inline bool operator () (uintE i) {$/;"	f	struct:Local_Update
operator ()	./apps/localAlg/sparseSet.h	/^    int operator() (kvPair a) {return a.first != UINT_E_MAX;}};$/;"	f	struct:sparseAdditiveSet::notEmptyF
operator ()	./apps/localAlg/sweep.h	/^  bool operator () (pairIF a, pairIF b) {$/;"	f	struct:sweep_compare
operator ()	./apps/localAlg/sweep.h	/^  bool operator() (pairIntT a, pairIntT b){$/;"	f	struct:edgeLessPair
operator ()	./apps/localAlg/sweep.h	/^  intT operator() (pairIntT a) { return a.second; }};$/;"	f	struct:extractSecond
operator ()	./apps/localAlg/sweep.h	/^struct addFirst { pairIntT operator() (pairIntT a, pairIntT b){$/;"	f	struct:addFirst
operator ()	./apps/localAlg/sweep.h	/^struct minDiPair { diPair operator() (diPair a, diPair b){$/;"	f	struct:minDiPair
operator ()	./apps/utils.h	/^    ET operator() (intT i) {return A[i];}$/;"	f	struct:sequence::getA
operator ()	./apps/utils.h	/^    OT operator () (intT i) {return f(A[i]);}$/;"	f	struct:sequence::getAF
operator ()	./apps/utils.h	/^    intT operator() (intT i) {return (intT) A[i];}$/;"	f	struct:sequence::boolGetA
operator ()	./apps/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	f	struct:addF
operator ()	./apps/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	f	struct:identityF
operator ()	./apps/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	f	struct:maxF
operator ()	./apps/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	f	struct:minF
operator ()	./apps/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	f	struct:nonMaxF
operator ()	./ligra/IO.h	/^  bool operator() (pair<uintE,E> a, pair<uintE,E> b) {$/;"	f	struct:pairFirstCmp
operator ()	./ligra/IO.h	/^  bool operator() (pair<uintE,IntType> a, pair<uintE,IntType> b) {$/;"	f	struct:pairBothCmp
operator ()	./ligra/IO.h	/^struct getFirst {uintE operator() (pair<uintE,E> a) {return a.first;} };$/;"	f	struct:getFirst
operator ()	./ligra/blockRadixSort.h	/^      long operator() (E p) {return _mask&(_f(p)>>_offset);}$/;"	f	struct:intSort::eBits
operator ()	./ligra/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	f	struct:firstF
operator ()	./ligra/encoder.C	/^  bool operator() (intTriple2 a, intTriple2 b) {$/;"	f	struct:tripleCmp
operator ()	./ligra/utils.h	/^    ET operator() (intT i) {return A[i];}$/;"	f	struct:sequence::getA
operator ()	./ligra/utils.h	/^    OT operator () (intT i) {return f(A[i]);}$/;"	f	struct:sequence::getAF
operator ()	./ligra/utils.h	/^    intT operator() (intT i) {return (intT) A[i];}$/;"	f	struct:sequence::boolGetA
operator ()	./ligra/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	f	struct:addF
operator ()	./ligra/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	f	struct:identityF
operator ()	./ligra/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	f	struct:maxF
operator ()	./ligra/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	f	struct:minF
operator ()	./ligra/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	f	struct:nonMaxF
operator ()	./tutorial/IO.h	/^  bool operator() (pair<uintE,E> a, pair<uintE,E> b) {$/;"	f	struct:pairFirstCmp
operator ()	./tutorial/IO.h	/^  bool operator() (pair<uintE,IntType> a, pair<uintE,IntType> b) {$/;"	f	struct:pairBothCmp
operator ()	./tutorial/IO.h	/^struct getFirst {uintE operator() (pair<uintE,E> a) {return a.first;} };$/;"	f	struct:getFirst
operator ()	./tutorial/KCore.C	/^  inline bool operator () (long i) {$/;"	f	struct:Deg_AtLeast_K
operator ()	./tutorial/KCore.C	/^  inline bool operator () (long i) {$/;"	f	struct:Deg_LessThan_K
operator ()	./tutorial/Radii.C	/^  inline bool operator() (long i) {$/;"	f	struct:Radii_Vertex_F
operator ()	./tutorial/blockRadixSort.h	/^      long operator() (E p) {return _mask&(_f(p)>>_offset);}$/;"	f	struct:intSort::eBits
operator ()	./tutorial/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	f	struct:firstF
operator ()	./tutorial/encoder.C	/^  bool operator() (intTriple2 a, intTriple2 b) {$/;"	f	struct:tripleCmp
operator ()	./tutorial/utils.h	/^    ET operator() (intT i) {return A[i];}$/;"	f	struct:sequence::getA
operator ()	./tutorial/utils.h	/^    OT operator () (intT i) {return f(A[i]);}$/;"	f	struct:sequence::getAF
operator ()	./tutorial/utils.h	/^    intT operator() (intT i) {return (intT) A[i];}$/;"	f	struct:sequence::boolGetA
operator ()	./tutorial/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	f	struct:addF
operator ()	./tutorial/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	f	struct:identityF
operator ()	./tutorial/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	f	struct:maxF
operator ()	./tutorial/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	f	struct:minF
operator ()	./tutorial/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	f	struct:nonMaxF
operator ()	./utils/blockRadixSort.h	/^      long operator() (E p) {return _mask&(_f(p)>>_offset);}$/;"	f	struct:intSort::eBits
operator ()	./utils/blockRadixSort.h	/^  struct firstF {E1 operator() (std::pair<E1,E2> a) {return a.first;} };$/;"	f	struct:firstF
operator ()	./utils/graphIO.h	/^  bool operator() (edge<uintT> e1, edge<uintT> e2) {$/;"	f	struct:edgeCmp
operator ()	./utils/graphIO.h	/^  struct notZero { bool operator() (char A) {return A > 0;}};$/;"	f	struct:benchIO::notZero
operator ()	./utils/graphIO.h	/^  struct toLong { long operator() (bool v) {return (long) v;} };$/;"	f	struct:benchIO::toLong
operator ()	./utils/graphIO.h	/^struct getuF {intT operator() (edge<intT> e) {return e.u;} };$/;"	f	struct:getuF
operator ()	./utils/graphIO.h	/^struct nEQF {bool operator() (edge<intT> e) {return (e.u != e.v);}};$/;"	f	struct:nEQF
operator ()	./utils/rMatGraph.C	/^  edge<intT> operator() (intT i) {$/;"	f	struct:rMat
operator ()	./utils/utils.h	/^    ET operator() (intT i) {return A[i];}$/;"	f	struct:sequence::getA
operator ()	./utils/utils.h	/^    OT operator () (intT i) {return f(A[i]);}$/;"	f	struct:sequence::getAF
operator ()	./utils/utils.h	/^    intT operator() (intT i) {return (intT) A[i];}$/;"	f	struct:sequence::boolGetA
operator ()	./utils/utils.h	/^struct addF { E operator() (const E& a, const E& b) const {return a+b;}};$/;"	f	struct:addF
operator ()	./utils/utils.h	/^struct identityF { E operator() (const E& x) {return x;}};$/;"	f	struct:identityF
operator ()	./utils/utils.h	/^struct maxF { E operator() (const E& a, const E& b) const {return (a>b) ? a : b;}};$/;"	f	struct:maxF
operator ()	./utils/utils.h	/^struct minF { E operator() (const E& a, const E& b) const {return (a < b) ? a : b;}};$/;"	f	struct:minF
operator ()	./utils/utils.h	/^struct nonMaxF{bool operator() (uintE &a) {return (a != UINT_E_MAX);}};$/;"	f	struct:nonMaxF
options	./apps/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	g
options	./ligra/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	g
options	./tutorial/ligra.h	/^enum options { DENSE, DENSE_FORWARD };$/;"	g
outDegree	./apps/compressedVertex.h	/^  uintT outDegree;$/;"	m	struct:compressedAsymmetricVertex
outDegree	./apps/vertex.h	/^  uintT outDegree;$/;"	m	struct:asymmetricVertex
outDegree	./ligra/compressedVertex.h	/^  uintT outDegree;$/;"	m	struct:compressedAsymmetricVertex
outDegree	./ligra/vertex.h	/^  uintT outDegree;$/;"	m	struct:asymmetricVertex
outDegree	./tutorial/compressedVertex.h	/^  uintT outDegree;$/;"	m	struct:compressedAsymmetricVertex
outDegree	./tutorial/vertex.h	/^  uintT outDegree;$/;"	m	struct:asymmetricVertex
outEdges	./apps/compressedVertex.h	/^    uintE *outEdges;$/;"	m	struct:decode_compressed::sparseT
outEdges	./ligra/compressedVertex.h	/^    uintE *outEdges;$/;"	m	struct:decode_compressed::sparseT
outEdges	./tutorial/compressedVertex.h	/^    uintE *outEdges;$/;"	m	struct:decode_compressed::sparseT
outNeighbors	./apps/compressedVertex.h	/^  uchar* outNeighbors;$/;"	m	struct:compressedAsymmetricVertex
outNeighbors	./apps/vertex.h	/^  uintE* inNeighbors, *outNeighbors;$/;"	m	struct:asymmetricVertex
outNeighbors	./ligra/compressedVertex.h	/^  uchar* outNeighbors;$/;"	m	struct:compressedAsymmetricVertex
outNeighbors	./ligra/vertex.h	/^  uintE* inNeighbors, *outNeighbors;$/;"	m	struct:asymmetricVertex
outNeighbors	./tutorial/compressedVertex.h	/^  uchar* outNeighbors;$/;"	m	struct:compressedAsymmetricVertex
outNeighbors	./tutorial/vertex.h	/^  uintE* inNeighbors, *outNeighbors;$/;"	m	struct:asymmetricVertex
p	./apps/PageRankDelta.C	/^  double* p, *Delta, *nghSum;$/;"	m	struct:PR_Vertex_F	file:
p	./apps/PageRankDelta.C	/^  double* p, *Delta, *nghSum;$/;"	m	struct:PR_Vertex_F_FirstRound	file:
p	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  sparseAdditiveSet<float> p, r, new_r;$/;"	m	struct:ACL_F	file:
p	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  sparseAdditiveSet<float> p, r;$/;"	m	struct:Local_Update	file:
p	./apps/localAlg/ACL-Sync-Local.C	/^  sparseAdditiveSet<float> p, r, new_r;$/;"	m	struct:ACL_F	file:
p	./apps/localAlg/ACL-Sync-Local.C	/^  sparseAdditiveSet<float> p, r;$/;"	m	struct:Local_Update	file:
p	./apps/localAlg/Nibble-Parallel.C	/^  sparseAdditiveSet<float> p, new_p;$/;"	m	struct:Local_Update	file:
p	./apps/localAlg/Nibble-Parallel.C	/^  sparseAdditiveSet<float> p, new_p;$/;"	m	struct:Nibble_F	file:
p_curr	./apps/PageRank.C	/^  double* p_curr, *p_next;$/;"	m	struct:PR_F	file:
p_curr	./apps/PageRank.C	/^  double* p_curr;$/;"	m	struct:PR_Vertex_F	file:
p_curr	./apps/PageRank.C	/^  double* p_curr;$/;"	m	struct:PR_Vertex_Reset	file:
p_next	./apps/PageRank.C	/^  double* p_curr, *p_next;$/;"	m	struct:PR_F	file:
p_next	./apps/PageRank.C	/^  double* p_next;$/;"	m	struct:PR_Vertex_F	file:
pack	./apps/utils.h	/^  _seq<ET> pack(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
pack	./apps/utils.h	/^  intT pack(ET* In, ET* Out, bool* Fl, intT n) {$/;"	f	namespace:sequence
pack	./ligra/utils.h	/^  _seq<ET> pack(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
pack	./ligra/utils.h	/^  intT pack(ET* In, ET* Out, bool* Fl, intT n) {$/;"	f	namespace:sequence
pack	./tutorial/utils.h	/^  _seq<ET> pack(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
pack	./tutorial/utils.h	/^  intT pack(ET* In, ET* Out, bool* Fl, intT n) {$/;"	f	namespace:sequence
pack	./utils/utils.h	/^  _seq<ET> pack(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
pack	./utils/utils.h	/^  intT pack(ET* In, ET* Out, bool* Fl, intT n) {$/;"	f	namespace:sequence
packIndex	./apps/utils.h	/^  _seq<intT> packIndex(bool* Fl, intT n) {$/;"	f	namespace:sequence
packIndex	./ligra/utils.h	/^  _seq<intT> packIndex(bool* Fl, intT n) {$/;"	f	namespace:sequence
packIndex	./tutorial/utils.h	/^  _seq<intT> packIndex(bool* Fl, intT n) {$/;"	f	namespace:sequence
packIndex	./utils/utils.h	/^  _seq<intT> packIndex(bool* Fl, intT n) {$/;"	f	namespace:sequence
packSerial	./apps/utils.h	/^  _seq<ET> packSerial(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
packSerial	./ligra/utils.h	/^  _seq<ET> packSerial(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
packSerial	./tutorial/utils.h	/^  _seq<ET> packSerial(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
packSerial	./utils/utils.h	/^  _seq<ET> packSerial(ET* Out, bool* Fl, intT s, intT e, F f) {$/;"	f	namespace:sequence
pairBothCmp	./apps/IO.h	/^struct pairBothCmp {$/;"	s
pairBothCmp	./ligra/IO.h	/^struct pairBothCmp {$/;"	s
pairBothCmp	./tutorial/IO.h	/^struct pairBothCmp {$/;"	s
pairDouble	./apps/localAlg/ACL-Serial-Naive.C	/^typedef pair<double,double> pairDouble;$/;"	t	file:
pairDouble	./apps/localAlg/ACL-Serial-Opt-Naive.C	/^typedef pair<double,double> pairDouble;$/;"	t	file:
pairDouble	./apps/localAlg/ACL-Serial-Opt.C	/^typedef pair<double,double> pairDouble;$/;"	t	file:
pairDouble	./apps/localAlg/ACL-Serial.C	/^typedef pair<double,double> pairDouble;$/;"	t	file:
pairDouble	./apps/localAlg/HeatKernel-Serial.C	/^typedef pair<double,double> pairDouble;$/;"	t	file:
pairDouble	./apps/localAlg/Nibble-Serial.C	/^typedef pair<double,double> pairDouble;$/;"	t	file:
pairDouble	./apps/localAlg/sweep.h	/^typedef pair<double,double> pairDouble;$/;"	t
pairFirstCmp	./apps/IO.h	/^struct pairFirstCmp {$/;"	s
pairFirstCmp	./ligra/IO.h	/^struct pairFirstCmp {$/;"	s
pairFirstCmp	./tutorial/IO.h	/^struct pairFirstCmp {$/;"	s
pairIF	./apps/localAlg/ACL-Serial-Naive.C	/^typedef pair<uintE,double> pairIF;$/;"	t	file:
pairIF	./apps/localAlg/ACL-Serial-Opt-Naive.C	/^typedef pair<uintE,double> pairIF;$/;"	t	file:
pairIF	./apps/localAlg/ACL-Serial-Opt.C	/^typedef pair<uintE,double> pairIF;$/;"	t	file:
pairIF	./apps/localAlg/ACL-Serial.C	/^typedef pair<uintE,double> pairIF;$/;"	t	file:
pairIF	./apps/localAlg/HeatKernel-Randomized-Serial.C	/^typedef pair<uintE,double> pairIF;$/;"	t	file:
pairIF	./apps/localAlg/HeatKernel-Serial.C	/^typedef pair<uintE,double> pairIF;$/;"	t	file:
pairIF	./apps/localAlg/Nibble-Serial.C	/^typedef pair<uintE,double> pairIF;$/;"	t	file:
pairIF	./apps/localAlg/sweep.h	/^typedef pair<uintE,double> pairIF;$/;"	t
pairInt	./apps/localAlg/HeatKernel-Serial.C	/^typedef pair<uintE,uintE> pairInt;$/;"	t	file:
pairIntT	./apps/localAlg/sweep.h	/^typedef pair<intT,intT> pairIntT;$/;"	t
parSweepCut	./apps/localAlg/sweep.h	/^  sweepObject parSweepCut(graph<vertex>& GA, pair<uintE,fType> *p, long numNonzeros, long start) {$/;"	f
parallelCompressEdges	./apps/byte-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./apps/byte.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./apps/byteRLE-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./apps/byteRLE.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./apps/nibble-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./apps/nibble.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./ligra/byte-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./ligra/byte.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./ligra/byteRLE-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./ligra/byteRLE.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./ligra/nibble-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./ligra/nibble.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./tutorial/byte-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./tutorial/byte.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./tutorial/byteRLE-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./tutorial/byteRLE.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./tutorial/nibble-pd.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressEdges	./tutorial/nibble.h	/^uintE *parallelCompressEdges(uintE *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./apps/byte-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./apps/byte.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./apps/byteRLE-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./apps/byteRLE.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./apps/nibble-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./apps/nibble.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./ligra/byte-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./ligra/byte.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./ligra/byteRLE-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./ligra/byteRLE.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./ligra/nibble-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./ligra/nibble.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./tutorial/byte-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./tutorial/byte.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./tutorial/byteRLE-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./tutorial/byteRLE.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./tutorial/nibble-pd.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallelCompressWeightedEdges	./tutorial/nibble.h	/^uchar *parallelCompressWeightedEdges(intEPair *edges, uintT *offsets, long n, long m, uintE* Degrees) {$/;"	f
parallel_for	./apps/parallel.h	30;"	d
parallel_for	./apps/parallel.h	53;"	d
parallel_for	./apps/parallel.h	80;"	d
parallel_for	./apps/parallel.h	91;"	d
parallel_for	./ligra/parallel.h	30;"	d
parallel_for	./ligra/parallel.h	53;"	d
parallel_for	./ligra/parallel.h	80;"	d
parallel_for	./ligra/parallel.h	91;"	d
parallel_for	./tutorial/parallel.h	30;"	d
parallel_for	./tutorial/parallel.h	53;"	d
parallel_for	./tutorial/parallel.h	80;"	d
parallel_for	./tutorial/parallel.h	91;"	d
parallel_for	./utils/parallel.h	30;"	d
parallel_for	./utils/parallel.h	53;"	d
parallel_for	./utils/parallel.h	80;"	d
parallel_for	./utils/parallel.h	91;"	d
parallel_for_1	./apps/parallel.h	31;"	d
parallel_for_1	./apps/parallel.h	55;"	d
parallel_for_1	./apps/parallel.h	81;"	d
parallel_for_1	./apps/parallel.h	92;"	d
parallel_for_1	./ligra/parallel.h	31;"	d
parallel_for_1	./ligra/parallel.h	55;"	d
parallel_for_1	./ligra/parallel.h	81;"	d
parallel_for_1	./ligra/parallel.h	92;"	d
parallel_for_1	./tutorial/parallel.h	31;"	d
parallel_for_1	./tutorial/parallel.h	55;"	d
parallel_for_1	./tutorial/parallel.h	81;"	d
parallel_for_1	./tutorial/parallel.h	92;"	d
parallel_for_1	./utils/parallel.h	31;"	d
parallel_for_1	./utils/parallel.h	55;"	d
parallel_for_1	./utils/parallel.h	81;"	d
parallel_for_1	./utils/parallel.h	92;"	d
parallel_for_256	./apps/parallel.h	32;"	d
parallel_for_256	./apps/parallel.h	56;"	d
parallel_for_256	./apps/parallel.h	82;"	d
parallel_for_256	./apps/parallel.h	93;"	d
parallel_for_256	./ligra/parallel.h	32;"	d
parallel_for_256	./ligra/parallel.h	56;"	d
parallel_for_256	./ligra/parallel.h	82;"	d
parallel_for_256	./ligra/parallel.h	93;"	d
parallel_for_256	./tutorial/parallel.h	32;"	d
parallel_for_256	./tutorial/parallel.h	56;"	d
parallel_for_256	./tutorial/parallel.h	82;"	d
parallel_for_256	./tutorial/parallel.h	93;"	d
parallel_for_256	./utils/parallel.h	32;"	d
parallel_for_256	./utils/parallel.h	56;"	d
parallel_for_256	./utils/parallel.h	82;"	d
parallel_for_256	./utils/parallel.h	93;"	d
parallel_main	./apps/encoder.C	/^int parallel_main(int argc, char* argv[]) {  $/;"	f
parallel_main	./apps/ligra.h	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./apps/parallel.h	29;"	d
parallel_main	./apps/parallel.h	54;"	d
parallel_main	./apps/parallel.h	79;"	d
parallel_main	./apps/parallel.h	90;"	d
parallel_main	./ligra/encoder.C	/^int parallel_main(int argc, char* argv[]) {  $/;"	f
parallel_main	./ligra/ligra.h	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./ligra/parallel.h	29;"	d
parallel_main	./ligra/parallel.h	54;"	d
parallel_main	./ligra/parallel.h	79;"	d
parallel_main	./ligra/parallel.h	90;"	d
parallel_main	./tutorial/encoder.C	/^int parallel_main(int argc, char* argv[]) {  $/;"	f
parallel_main	./tutorial/ligra.h	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./tutorial/parallel.h	29;"	d
parallel_main	./tutorial/parallel.h	54;"	d
parallel_main	./tutorial/parallel.h	79;"	d
parallel_main	./tutorial/parallel.h	90;"	d
parallel_main	./utils/SNAPtoAdj.C	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./utils/adjGraphAddWeights.C	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./utils/adjToBinary.C	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./utils/gridGraph.C	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./utils/parallel.h	29;"	d
parallel_main	./utils/parallel.h	54;"	d
parallel_main	./utils/parallel.h	79;"	d
parallel_main	./utils/parallel.h	90;"	d
parallel_main	./utils/rMatGraph.C	/^int parallel_main(int argc, char* argv[]) {$/;"	f
parallel_main	./utils/randLocalGraph.C	/^int parallel_main(int argc, char* argv[]) {$/;"	f
plusReduce	./apps/utils.h	/^  OT plusReduce(OT* A, intT n) {$/;"	f	namespace:sequence
plusReduce	./ligra/utils.h	/^  OT plusReduce(OT* A, intT n) {$/;"	f	namespace:sequence
plusReduce	./tutorial/utils.h	/^  OT plusReduce(OT* A, intT n) {$/;"	f	namespace:sequence
plusReduce	./utils/utils.h	/^  OT plusReduce(OT* A, intT n) {$/;"	f	namespace:sequence
plusScan	./apps/utils.h	/^  ET plusScan(ET *In, ET* Out, intT n) {$/;"	f	namespace:sequence
plusScan	./ligra/utils.h	/^  ET plusScan(ET *In, ET* Out, intT n) {$/;"	f	namespace:sequence
plusScan	./tutorial/utils.h	/^  ET plusScan(ET *In, ET* Out, intT n) {$/;"	f	namespace:sequence
plusScan	./utils/utils.h	/^  ET plusScan(ET *In, ET* Out, intT n) {$/;"	f	namespace:sequence
pq_compare	./apps/localAlg/ACL-Serial-Naive.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	s	file:
pq_compare	./apps/localAlg/ACL-Serial-Opt-Naive.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	s	file:
pq_compare	./apps/localAlg/ACL-Serial-Opt.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	s	file:
pq_compare	./apps/localAlg/ACL-Serial.C	/^struct pq_compare { bool operator () (pairIF a, pairIF b) {$/;"	s	file:
prevIDs	./apps/Components.C	/^  uintE* IDs, *prevIDs;$/;"	m	struct:CC_F	file:
prevIDs	./apps/Components.C	/^  uintE* IDs, *prevIDs;$/;"	m	struct:CC_Vertex_F	file:
prevIDs	./apps/eccentricity/CCBFS.h	/^  intE* IDs, *prevIDs;$/;"	m	struct:CC_F
prevIDs	./apps/eccentricity/CCBFS.h	/^  intE* IDs, *prevIDs;$/;"	m	struct:CC_Vertex_F
print	./apps/localAlg/sparseSet.h	/^  void print() {$/;"	f	class:sparseAdditiveSet
print	./apps/vertexSubset.h	/^  void print() {$/;"	f	struct:vertexSubset
print	./ligra/vertexSubset.h	/^  void print() {$/;"	f	struct:vertexSubset
print	./tutorial/vertexSubset.h	/^  void print() {$/;"	f	struct:vertexSubset
quickSort	./apps/quickSort.h	/^void quickSort(E* A, intT n, BinPred f) {$/;"	f
quickSort	./ligra/quickSort.h	/^void quickSort(E* A, intT n, BinPred f) {$/;"	f
quickSort	./tutorial/quickSort.h	/^void quickSort(E* A, intT n, BinPred f) {$/;"	f
quickSort	./utils/quickSort.h	/^void quickSort(E* A, intT n, BinPred f) {$/;"	f
r	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  sparseAdditiveSet<float> p, r, new_r;$/;"	m	struct:ACL_F	file:
r	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  sparseAdditiveSet<float> p, r;$/;"	m	struct:Local_Update	file:
r	./apps/localAlg/ACL-Sync-Local.C	/^  sparseAdditiveSet<float> p, r, new_r;$/;"	m	struct:ACL_F	file:
r	./apps/localAlg/ACL-Sync-Local.C	/^  sparseAdditiveSet<float> p, r;$/;"	m	struct:Local_Update	file:
r	./apps/localAlg/HeatKernel-Parallel.C	/^  sparseAdditiveSet<float> x, r, new_r;$/;"	m	struct:HK_F	file:
r	./apps/localAlg/HeatKernel-Parallel.C	/^  sparseAdditiveSet<float> x, r;$/;"	m	struct:HK_Last_F	file:
r	./apps/localAlg/HeatKernel-Parallel.C	/^  sparseAdditiveSet<float> x, r;$/;"	m	struct:Local_Update	file:
rMat	./utils/rMatGraph.C	/^  rMat(intT _n, intT _seed, $/;"	f	struct:rMat
rMat	./utils/rMatGraph.C	/^struct rMat {$/;"	s	file:
rMatRec	./utils/rMatGraph.C	/^  edge<intT> rMatRec(intT nn, intT randStart, intT randStride) {$/;"	f	struct:rMat
radii	./apps/Radii.C	/^  intE* radii;$/;"	m	struct:Radii_F	file:
radii	./tutorial/Radii.C	/^  long* radii;$/;"	m	struct:Radii_F	file:
radixBlock	./apps/blockRadixSort.h	/^  void radixBlock(E* A, E* B, bIndexT *Tmp, $/;"	f	namespace:intSort
radixBlock	./ligra/blockRadixSort.h	/^  void radixBlock(E* A, E* B, bIndexT *Tmp, $/;"	f	namespace:intSort
radixBlock	./tutorial/blockRadixSort.h	/^  void radixBlock(E* A, E* B, bIndexT *Tmp, $/;"	f	namespace:intSort
radixBlock	./utils/blockRadixSort.h	/^  void radixBlock(E* A, E* B, bIndexT *Tmp, $/;"	f	namespace:intSort
radixLoopBottomUp	./apps/blockRadixSort.h	/^    void radixLoopBottomUp(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixLoopBottomUp	./ligra/blockRadixSort.h	/^    void radixLoopBottomUp(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixLoopBottomUp	./tutorial/blockRadixSort.h	/^    void radixLoopBottomUp(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixLoopBottomUp	./utils/blockRadixSort.h	/^    void radixLoopBottomUp(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixLoopTopDown	./apps/blockRadixSort.h	/^    void radixLoopTopDown(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixLoopTopDown	./ligra/blockRadixSort.h	/^    void radixLoopTopDown(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixLoopTopDown	./tutorial/blockRadixSort.h	/^    void radixLoopTopDown(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixLoopTopDown	./utils/blockRadixSort.h	/^    void radixLoopTopDown(E *A, E *B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixStep	./apps/blockRadixSort.h	/^    void radixStep(E* A, E* B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixStep	./ligra/blockRadixSort.h	/^    void radixStep(E* A, E* B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixStep	./tutorial/blockRadixSort.h	/^    void radixStep(E* A, E* B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixStep	./utils/blockRadixSort.h	/^    void radixStep(E* A, E* B, bIndexT *Tmp, bint (*BK)[BUCKETS],$/;"	f	namespace:intSort
radixStepSerial	./apps/blockRadixSort.h	/^  void radixStepSerial(E* A, E* B, bIndexT *Tmp, bint buckets[BUCKETS],$/;"	f	namespace:intSort
radixStepSerial	./ligra/blockRadixSort.h	/^  void radixStepSerial(E* A, E* B, bIndexT *Tmp, bint buckets[BUCKETS],$/;"	f	namespace:intSort
radixStepSerial	./tutorial/blockRadixSort.h	/^  void radixStepSerial(E* A, E* B, bIndexT *Tmp, bint buckets[BUCKETS],$/;"	f	namespace:intSort
radixStepSerial	./utils/blockRadixSort.h	/^  void radixStepSerial(E* A, E* B, bIndexT *Tmp, bint buckets[BUCKETS],$/;"	f	namespace:intSort
readCompressedGraph	./apps/IO.h	/^graph<vertex> readCompressedGraph(char* fname, bool isSymmetric) {$/;"	f
readCompressedGraph	./ligra/IO.h	/^graph<vertex> readCompressedGraph(char* fname, bool isSymmetric) {$/;"	f
readCompressedGraph	./tutorial/IO.h	/^graph<vertex> readCompressedGraph(char* fname, bool isSymmetric) {$/;"	f
readGraph	./apps/IO.h	/^graph<vertex> readGraph(char* iFile, bool compressed, bool symmetric, bool binary) {$/;"	f
readGraph	./ligra/IO.h	/^graph<vertex> readGraph(char* iFile, bool compressed, bool symmetric, bool binary) {$/;"	f
readGraph	./tutorial/IO.h	/^graph<vertex> readGraph(char* iFile, bool compressed, bool symmetric, bool binary) {$/;"	f
readGraphFromBinary	./apps/IO.h	/^graph<vertex> readGraphFromBinary(char* iFile, bool isSymmetric) {$/;"	f
readGraphFromBinary	./ligra/IO.h	/^graph<vertex> readGraphFromBinary(char* iFile, bool isSymmetric) {$/;"	f
readGraphFromBinary	./tutorial/IO.h	/^graph<vertex> readGraphFromBinary(char* iFile, bool isSymmetric) {$/;"	f
readGraphFromFile	./apps/IO.h	/^graph<vertex> readGraphFromFile(char* fname, bool isSymmetric) {$/;"	f
readGraphFromFile	./ligra/IO.h	/^graph<vertex> readGraphFromFile(char* fname, bool isSymmetric) {$/;"	f
readGraphFromFile	./tutorial/IO.h	/^graph<vertex> readGraphFromFile(char* fname, bool isSymmetric) {$/;"	f
readGraphFromFile	./utils/graphIO.h	/^  graph<intT> readGraphFromFile(char* fname) {$/;"	f	namespace:benchIO
readSNAP	./utils/graphIO.h	/^  edgeArray<intT> readSNAP(char* fname) {$/;"	f	namespace:benchIO
readStringFromFile	./apps/IO.h	/^_seq<char> readStringFromFile(char *fileName) {$/;"	f
readStringFromFile	./ligra/IO.h	/^_seq<char> readStringFromFile(char *fileName) {$/;"	f
readStringFromFile	./tutorial/IO.h	/^_seq<char> readStringFromFile(char *fileName) {$/;"	f
readStringFromFile	./utils/graphIO.h	/^  _seq<char> readStringFromFile(char *fileName) {$/;"	f	namespace:benchIO
readWghGraphFromFile	./utils/graphIO.h	/^    wghGraph<intT> readWghGraphFromFile(char* fname) {$/;"	f	namespace:benchIO
reduce	./apps/utils.h	/^  OT reduce(OT* A, intT n, F f) {$/;"	f	namespace:sequence
reduce	./apps/utils.h	/^  OT reduce(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
reduce	./ligra/utils.h	/^  OT reduce(OT* A, intT n, F f) {$/;"	f	namespace:sequence
reduce	./ligra/utils.h	/^  OT reduce(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
reduce	./tutorial/utils.h	/^  OT reduce(OT* A, intT n, F f) {$/;"	f	namespace:sequence
reduce	./tutorial/utils.h	/^  OT reduce(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
reduce	./utils/utils.h	/^  OT reduce(OT* A, intT n, F f) {$/;"	f	namespace:sequence
reduce	./utils/utils.h	/^  OT reduce(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
reduceSerial	./apps/utils.h	/^  OT reduceSerial(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
reduceSerial	./ligra/utils.h	/^  OT reduceSerial(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
reduceSerial	./tutorial/utils.h	/^  OT reduceSerial(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
reduceSerial	./utils/utils.h	/^  OT reduceSerial(intT s, intT e, F f, G g) {$/;"	f	namespace:sequence
remDuplicates	./apps/utils.h	/^void remDuplicates(uintE* indices, uintE* flags, long m, long n) {$/;"	f
remDuplicates	./ligra/utils.h	/^void remDuplicates(uintE* indices, uintE* flags, long m, long n) {$/;"	f
remDuplicates	./tutorial/utils.h	/^void remDuplicates(uintE* indices, uintE* flags, long m, long n) {$/;"	f
remDuplicates	./utils/graphIO.h	/^edgeArray<intT> remDuplicates(edgeArray<intT> A) {$/;"	f
remDuplicates	./utils/utils.h	/^void remDuplicates(uintE* indices, uintE* flags, long m, long n) {$/;"	f
reportAll	./apps/eccentricity/CLRSTV.C	/^void reportAll() {$/;"	f
reportAll	./apps/eccentricity/FM-Ecc.C	/^void reportAll() {$/;"	f
reportAll	./apps/eccentricity/LogLog-Ecc.C	/^void reportAll() {$/;"	f
reportAll	./apps/eccentricity/RV.C	/^void reportAll() {$/;"	f
reportAll	./apps/eccentricity/Simple-Approx-Ecc.C	/^void reportAll() {$/;"	f
reportAll	./apps/eccentricity/TK.C	/^void reportAll() {$/;"	f
reportAll	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^void reportAll() {$/;"	f
reportAll	./apps/eccentricity/kBFS-Ecc.C	/^void reportAll() {$/;"	f
reportNext	./apps/gettime.h	/^  void reportNext() {reportTime(next());}$/;"	f	struct:timer
reportNext	./apps/gettime.h	/^  void reportNext(std::string str) {std::cout << str << " : "; reportNext();}$/;"	f	struct:timer
reportNext	./ligra/gettime.h	/^  void reportNext() {reportTime(next());}$/;"	f	struct:timer
reportNext	./ligra/gettime.h	/^  void reportNext(std::string str) {std::cout << str << " : "; reportNext();}$/;"	f	struct:timer
reportNext	./tutorial/gettime.h	/^  void reportNext() {reportTime(next());}$/;"	f	struct:timer
reportNext	./tutorial/gettime.h	/^  void reportNext(std::string str) {std::cout << str << " : "; reportNext();}$/;"	f	struct:timer
reportStop	./apps/gettime.h	/^  void reportStop(double weight, std::string str) {$/;"	f	struct:timer
reportStop	./ligra/gettime.h	/^  void reportStop(double weight, std::string str) {$/;"	f	struct:timer
reportStop	./tutorial/gettime.h	/^  void reportStop(double weight, std::string str) {$/;"	f	struct:timer
reportT	./apps/gettime.h	/^  void reportT(double time) {$/;"	f	struct:timer
reportT	./ligra/gettime.h	/^  void reportT(double time) {$/;"	f	struct:timer
reportT	./tutorial/gettime.h	/^  void reportT(double time) {$/;"	f	struct:timer
reportTime	./apps/gettime.h	/^  void reportTime(double time) {$/;"	f	struct:timer
reportTime	./apps/gettime.h	111;"	d
reportTime	./ligra/gettime.h	/^  void reportTime(double time) {$/;"	f	struct:timer
reportTime	./ligra/gettime.h	111;"	d
reportTime	./tutorial/gettime.h	/^  void reportTime(double time) {$/;"	f	struct:timer
reportTime	./tutorial/gettime.h	111;"	d
reportTotal	./apps/gettime.h	/^  void reportTotal() {$/;"	f	struct:timer
reportTotal	./apps/gettime.h	/^  void reportTotal(std::string str) {$/;"	f	struct:timer
reportTotal	./ligra/gettime.h	/^  void reportTotal() {$/;"	f	struct:timer
reportTotal	./ligra/gettime.h	/^  void reportTotal(std::string str) {$/;"	f	struct:timer
reportTotal	./tutorial/gettime.h	/^  void reportTotal() {$/;"	f	struct:timer
reportTotal	./tutorial/gettime.h	/^  void reportTotal(std::string str) {$/;"	f	struct:timer
round	./apps/Radii.C	/^  intE round;$/;"	m	struct:Radii_F	file:
round	./apps/eccentricity/CLRSTV.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
round	./apps/eccentricity/FM-Ecc.C	/^  intE round;$/;"	m	struct:Ecc_F	file:
round	./apps/eccentricity/LogLog-Ecc.C	/^  intE round;$/;"	m	struct:Ecc_F	file:
round	./apps/eccentricity/RV.C	/^  intPair* Dist; uintE round;$/;"	m	struct:BFS_Pair_F	file:
round	./apps/eccentricity/RV.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
round	./apps/eccentricity/Simple-Approx-Ecc.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
round	./apps/eccentricity/TK.C	/^  uintE* Dist; uintE round;$/;"	m	struct:BFS_F	file:
round	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  uintE round;$/;"	m	struct:Ecc_F	file:
round	./apps/eccentricity/kBFS-Ecc.C	/^  uintE round;$/;"	m	struct:Ecc_F	file:
round	./apps/eccentricity/kBFS-Exact.C	/^  uintE round;$/;"	m	struct:Ecc_F	file:
round	./tutorial/Radii.C	/^  long round;$/;"	m	struct:Radii_F	file:
s	./apps/IO.h	/^  char* s;$/;"	m	struct:Compressed_Mem
s	./apps/vertexSubset.h	/^  uintE* s;$/;"	m	struct:vertexSubset
s	./ligra/IO.h	/^  char* s;$/;"	m	struct:Compressed_Mem
s	./ligra/vertexSubset.h	/^  uintE* s;$/;"	m	struct:vertexSubset
s	./tutorial/IO.h	/^  char* s;$/;"	m	struct:Compressed_Mem
s	./tutorial/vertexSubset.h	/^  uintE* s;$/;"	m	struct:vertexSubset
s1	./apps/localAlg/sweep.h	/^timer s1,s2;$/;"	v
s2	./apps/localAlg/sweep.h	/^timer s1,s2;$/;"	v
sampleSort	./apps/localAlg/sampleSort.h	/^void sampleSort (E* A, intT n, BinPred f) {$/;"	f
scan	./apps/utils.h	/^  ET scan(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scan	./apps/utils.h	/^  ET scan(ET* Out, intT s, intT e, F f, G g,  ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
scan	./ligra/utils.h	/^  ET scan(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scan	./ligra/utils.h	/^  ET scan(ET* Out, intT s, intT e, F f, G g,  ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
scan	./tutorial/utils.h	/^  ET scan(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scan	./tutorial/utils.h	/^  ET scan(ET* Out, intT s, intT e, F f, G g,  ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
scan	./utils/utils.h	/^  ET scan(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scan	./utils/utils.h	/^  ET scan(ET* Out, intT s, intT e, F f, G g,  ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
scanBack	./apps/utils.h	/^  ET scanBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanBack	./ligra/utils.h	/^  ET scanBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanBack	./tutorial/utils.h	/^  ET scanBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanBack	./utils/utils.h	/^  ET scanBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanI	./apps/utils.h	/^  ET scanI(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanI	./ligra/utils.h	/^  ET scanI(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanI	./tutorial/utils.h	/^  ET scanI(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanI	./utils/utils.h	/^  ET scanI(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanIBack	./apps/utils.h	/^  ET scanIBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanIBack	./ligra/utils.h	/^  ET scanIBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanIBack	./tutorial/utils.h	/^  ET scanIBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanIBack	./utils/utils.h	/^  ET scanIBack(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanSerial	./apps/utils.h	/^  ET scanSerial(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanSerial	./apps/utils.h	/^  ET scanSerial(ET* Out, intT s, intT e, F f, G g, ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
scanSerial	./ligra/utils.h	/^  ET scanSerial(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanSerial	./ligra/utils.h	/^  ET scanSerial(ET* Out, intT s, intT e, F f, G g, ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
scanSerial	./tutorial/utils.h	/^  ET scanSerial(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanSerial	./tutorial/utils.h	/^  ET scanSerial(ET* Out, intT s, intT e, F f, G g, ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
scanSerial	./utils/utils.h	/^  ET scanSerial(ET *In, ET* Out, intT n, F f, ET zero) {$/;"	f	namespace:sequence
scanSerial	./utils/utils.h	/^  ET scanSerial(ET* Out, intT s, intT e, F f, G g, ET zero, bool inclusive, bool back) {$/;"	f	namespace:sequence
sequence	./apps/utils.h	/^namespace sequence {$/;"	n
sequence	./ligra/utils.h	/^namespace sequence {$/;"	n
sequence	./tutorial/utils.h	/^namespace sequence {$/;"	n
sequence	./utils/utils.h	/^namespace sequence {$/;"	n
sequentialCompressEdgeSet	./apps/byte-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./apps/byte.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./apps/byteRLE-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, uintE *savedEdges) {$/;"	f
sequentialCompressEdgeSet	./apps/byteRLE.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, uintE *savedEdges) {$/;"	f
sequentialCompressEdgeSet	./apps/nibble-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./apps/nibble.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./ligra/byte-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./ligra/byte.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./ligra/byteRLE-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, uintE *savedEdges) {$/;"	f
sequentialCompressEdgeSet	./ligra/byteRLE.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, uintE *savedEdges) {$/;"	f
sequentialCompressEdgeSet	./ligra/nibble-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./ligra/nibble.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./tutorial/byte-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./tutorial/byte.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./tutorial/byteRLE-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, uintE *savedEdges) {$/;"	f
sequentialCompressEdgeSet	./tutorial/byteRLE.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, uintE *savedEdges) {$/;"	f
sequentialCompressEdgeSet	./tutorial/nibble-pd.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressEdgeSet	./tutorial/nibble.h	/^long sequentialCompressEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, $/;"	f
sequentialCompressWeightedEdgeSet	./apps/byte-pd.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./apps/byte.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./apps/byteRLE-pd.h	/^long sequentialCompressWeightedEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, intEPair *savedEdges) {$/;"	f
sequentialCompressWeightedEdgeSet	./apps/byteRLE.h	/^long sequentialCompressWeightedEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, intEPair *savedEdges) {$/;"	f
sequentialCompressWeightedEdgeSet	./apps/nibble-pd.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./apps/nibble.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./ligra/byte-pd.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./ligra/byte.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./ligra/byteRLE-pd.h	/^long sequentialCompressWeightedEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, intEPair *savedEdges) {$/;"	f
sequentialCompressWeightedEdgeSet	./ligra/byteRLE.h	/^long sequentialCompressWeightedEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, intEPair *savedEdges) {$/;"	f
sequentialCompressWeightedEdgeSet	./ligra/nibble-pd.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./ligra/nibble.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./tutorial/byte-pd.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./tutorial/byte.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./tutorial/byteRLE-pd.h	/^long sequentialCompressWeightedEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, intEPair *savedEdges) {$/;"	f
sequentialCompressWeightedEdgeSet	./tutorial/byteRLE.h	/^long sequentialCompressWeightedEdgeSet(uchar *edgeArray, long currentOffset, uintT degree, uintE vertexNum, intEPair *savedEdges) {$/;"	f
sequentialCompressWeightedEdgeSet	./tutorial/nibble-pd.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
sequentialCompressWeightedEdgeSet	./tutorial/nibble.h	/^long sequentialCompressWeightedEdgeSet$/;"	f
setInDegree	./apps/compressedVertex.h	/^  void setInDegree(uintT _d) { degree = _d; }$/;"	f	struct:compressedSymmetricVertex
setInDegree	./apps/compressedVertex.h	/^  void setInDegree(uintT _d) { inDegree = _d; }$/;"	f	struct:compressedAsymmetricVertex
setInDegree	./apps/vertex.h	/^  void setInDegree(uintT _d) { degree = _d; }$/;"	f	struct:symmetricVertex
setInDegree	./apps/vertex.h	/^  void setInDegree(uintT _d) { inDegree = _d; }$/;"	f	struct:asymmetricVertex
setInDegree	./ligra/compressedVertex.h	/^  void setInDegree(uintT _d) { degree = _d; }$/;"	f	struct:compressedSymmetricVertex
setInDegree	./ligra/compressedVertex.h	/^  void setInDegree(uintT _d) { inDegree = _d; }$/;"	f	struct:compressedAsymmetricVertex
setInDegree	./ligra/vertex.h	/^  void setInDegree(uintT _d) { degree = _d; }$/;"	f	struct:symmetricVertex
setInDegree	./ligra/vertex.h	/^  void setInDegree(uintT _d) { inDegree = _d; }$/;"	f	struct:asymmetricVertex
setInDegree	./tutorial/compressedVertex.h	/^  void setInDegree(uintT _d) { degree = _d; }$/;"	f	struct:compressedSymmetricVertex
setInDegree	./tutorial/compressedVertex.h	/^  void setInDegree(uintT _d) { inDegree = _d; }$/;"	f	struct:compressedAsymmetricVertex
setInDegree	./tutorial/vertex.h	/^  void setInDegree(uintT _d) { degree = _d; }$/;"	f	struct:symmetricVertex
setInDegree	./tutorial/vertex.h	/^  void setInDegree(uintT _d) { inDegree = _d; }$/;"	f	struct:asymmetricVertex
setInNeighbors	./apps/compressedVertex.h	/^  void setInNeighbors(uchar* _i) { inNeighbors = _i; }$/;"	f	struct:compressedAsymmetricVertex
setInNeighbors	./apps/compressedVertex.h	/^  void setInNeighbors(uchar* _i) { neighbors = _i; }$/;"	f	struct:compressedSymmetricVertex
setInNeighbors	./apps/vertex.h	/^  void setInNeighbors(intE* _i) { inNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setInNeighbors	./apps/vertex.h	/^  void setInNeighbors(intE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setInNeighbors	./apps/vertex.h	/^  void setInNeighbors(uintE* _i) { inNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setInNeighbors	./apps/vertex.h	/^  void setInNeighbors(uintE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setInNeighbors	./ligra/compressedVertex.h	/^  void setInNeighbors(uchar* _i) { inNeighbors = _i; }$/;"	f	struct:compressedAsymmetricVertex
setInNeighbors	./ligra/compressedVertex.h	/^  void setInNeighbors(uchar* _i) { neighbors = _i; }$/;"	f	struct:compressedSymmetricVertex
setInNeighbors	./ligra/vertex.h	/^  void setInNeighbors(intE* _i) { inNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setInNeighbors	./ligra/vertex.h	/^  void setInNeighbors(intE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setInNeighbors	./ligra/vertex.h	/^  void setInNeighbors(uintE* _i) { inNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setInNeighbors	./ligra/vertex.h	/^  void setInNeighbors(uintE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setInNeighbors	./tutorial/compressedVertex.h	/^  void setInNeighbors(uchar* _i) { inNeighbors = _i; }$/;"	f	struct:compressedAsymmetricVertex
setInNeighbors	./tutorial/compressedVertex.h	/^  void setInNeighbors(uchar* _i) { neighbors = _i; }$/;"	f	struct:compressedSymmetricVertex
setInNeighbors	./tutorial/vertex.h	/^  void setInNeighbors(intE* _i) { inNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setInNeighbors	./tutorial/vertex.h	/^  void setInNeighbors(intE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setInNeighbors	./tutorial/vertex.h	/^  void setInNeighbors(uintE* _i) { inNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setInNeighbors	./tutorial/vertex.h	/^  void setInNeighbors(uintE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setOutDegree	./apps/compressedVertex.h	/^  void setOutDegree(uintT _d) { degree = _d; }$/;"	f	struct:compressedSymmetricVertex
setOutDegree	./apps/compressedVertex.h	/^  void setOutDegree(uintT _d) { outDegree = _d; }$/;"	f	struct:compressedAsymmetricVertex
setOutDegree	./apps/vertex.h	/^  void setOutDegree(uintT _d) { degree = _d; }$/;"	f	struct:symmetricVertex
setOutDegree	./apps/vertex.h	/^  void setOutDegree(uintT _d) { outDegree = _d; }$/;"	f	struct:asymmetricVertex
setOutDegree	./ligra/compressedVertex.h	/^  void setOutDegree(uintT _d) { degree = _d; }$/;"	f	struct:compressedSymmetricVertex
setOutDegree	./ligra/compressedVertex.h	/^  void setOutDegree(uintT _d) { outDegree = _d; }$/;"	f	struct:compressedAsymmetricVertex
setOutDegree	./ligra/vertex.h	/^  void setOutDegree(uintT _d) { degree = _d; }$/;"	f	struct:symmetricVertex
setOutDegree	./ligra/vertex.h	/^  void setOutDegree(uintT _d) { outDegree = _d; }$/;"	f	struct:asymmetricVertex
setOutDegree	./tutorial/compressedVertex.h	/^  void setOutDegree(uintT _d) { degree = _d; }$/;"	f	struct:compressedSymmetricVertex
setOutDegree	./tutorial/compressedVertex.h	/^  void setOutDegree(uintT _d) { outDegree = _d; }$/;"	f	struct:compressedAsymmetricVertex
setOutDegree	./tutorial/vertex.h	/^  void setOutDegree(uintT _d) { degree = _d; }$/;"	f	struct:symmetricVertex
setOutDegree	./tutorial/vertex.h	/^  void setOutDegree(uintT _d) { outDegree = _d; }$/;"	f	struct:asymmetricVertex
setOutNeighbors	./apps/compressedVertex.h	/^  void setOutNeighbors(uchar* _i) { neighbors = _i; }$/;"	f	struct:compressedSymmetricVertex
setOutNeighbors	./apps/compressedVertex.h	/^  void setOutNeighbors(uchar* _i) { outNeighbors = _i; }$/;"	f	struct:compressedAsymmetricVertex
setOutNeighbors	./apps/vertex.h	/^  void setOutNeighbors(intE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setOutNeighbors	./apps/vertex.h	/^  void setOutNeighbors(intE* _i) { outNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setOutNeighbors	./apps/vertex.h	/^  void setOutNeighbors(uintE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setOutNeighbors	./apps/vertex.h	/^  void setOutNeighbors(uintE* _i) { outNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setOutNeighbors	./ligra/compressedVertex.h	/^  void setOutNeighbors(uchar* _i) { neighbors = _i; }$/;"	f	struct:compressedSymmetricVertex
setOutNeighbors	./ligra/compressedVertex.h	/^  void setOutNeighbors(uchar* _i) { outNeighbors = _i; }$/;"	f	struct:compressedAsymmetricVertex
setOutNeighbors	./ligra/vertex.h	/^  void setOutNeighbors(intE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setOutNeighbors	./ligra/vertex.h	/^  void setOutNeighbors(intE* _i) { outNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setOutNeighbors	./ligra/vertex.h	/^  void setOutNeighbors(uintE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setOutNeighbors	./ligra/vertex.h	/^  void setOutNeighbors(uintE* _i) { outNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setOutNeighbors	./tutorial/compressedVertex.h	/^  void setOutNeighbors(uchar* _i) { neighbors = _i; }$/;"	f	struct:compressedSymmetricVertex
setOutNeighbors	./tutorial/compressedVertex.h	/^  void setOutNeighbors(uchar* _i) { outNeighbors = _i; }$/;"	f	struct:compressedAsymmetricVertex
setOutNeighbors	./tutorial/vertex.h	/^  void setOutNeighbors(intE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setOutNeighbors	./tutorial/vertex.h	/^  void setOutNeighbors(intE* _i) { outNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setOutNeighbors	./tutorial/vertex.h	/^  void setOutNeighbors(uintE* _i) { neighbors = _i; }$/;"	f	struct:symmetricVertex
setOutNeighbors	./tutorial/vertex.h	/^  void setOutNeighbors(uintE* _i) { outNeighbors = _i; }$/;"	f	struct:asymmetricVertex
setWorkers	./apps/parallel.h	/^static void setWorkers(int n) { omp_set_num_threads(n); }$/;"	f
setWorkers	./apps/parallel.h	/^static void setWorkers(int n) { }$/;"	f
setWorkers	./apps/parallel.h	/^static void setWorkers(int n) {$/;"	f
setWorkers	./ligra/parallel.h	/^static void setWorkers(int n) { omp_set_num_threads(n); }$/;"	f
setWorkers	./ligra/parallel.h	/^static void setWorkers(int n) { }$/;"	f
setWorkers	./ligra/parallel.h	/^static void setWorkers(int n) {$/;"	f
setWorkers	./tutorial/parallel.h	/^static void setWorkers(int n) { omp_set_num_threads(n); }$/;"	f
setWorkers	./tutorial/parallel.h	/^static void setWorkers(int n) { }$/;"	f
setWorkers	./tutorial/parallel.h	/^static void setWorkers(int n) {$/;"	f
setWorkers	./utils/parallel.h	/^static void setWorkers(int n) { omp_set_num_threads(n); }$/;"	f
setWorkers	./utils/parallel.h	/^static void setWorkers(int n) { }$/;"	f
setWorkers	./utils/parallel.h	/^static void setWorkers(int n) {$/;"	f
sizeAndFileName	./apps/parseCommandLine.h	/^  pair<int,char*> sizeAndFileName() {$/;"	f	struct:commandLine
sizeAndFileName	./ligra/parseCommandLine.h	/^  pair<int,char*> sizeAndFileName() {$/;"	f	struct:commandLine
sizeAndFileName	./tutorial/parseCommandLine.h	/^  pair<int,char*> sizeAndFileName() {$/;"	f	struct:commandLine
sizeAndFileName	./utils/parseCommandLine.h	/^  pair<int,char*> sizeAndFileName() {$/;"	f	struct:commandLine
sizeS	./apps/localAlg/sweep.h	/^  long sizeS, volS, vol, edgesCrossing;$/;"	m	struct:sweepObject
sparseAdditiveSet	./apps/localAlg/sparseSet.h	/^ sparseAdditiveSet(long size, float _loadFactor, E zero) :$/;"	f	class:sparseAdditiveSet
sparseAdditiveSet	./apps/localAlg/sparseSet.h	/^class sparseAdditiveSet {$/;"	c
sparseT	./apps/compressedVertex.h	/^  sparseT(uintT vP, uintT oP, uintE *outEdgesP) : v(vP), o(oP), outEdges(outEdgesP) {}$/;"	f	struct:decode_compressed::sparseT
sparseT	./apps/compressedVertex.h	/^  struct sparseT {$/;"	s	namespace:decode_compressed
sparseT	./ligra/compressedVertex.h	/^  sparseT(uintT vP, uintT oP, uintE *outEdgesP) : v(vP), o(oP), outEdges(outEdgesP) {}$/;"	f	struct:decode_compressed::sparseT
sparseT	./ligra/compressedVertex.h	/^  struct sparseT {$/;"	s	namespace:decode_compressed
sparseT	./tutorial/compressedVertex.h	/^  sparseT(uintT vP, uintT oP, uintE *outEdgesP) : v(vP), o(oP), outEdges(outEdgesP) {}$/;"	f	struct:decode_compressed::sparseT
sparseT	./tutorial/compressedVertex.h	/^  struct sparseT {$/;"	s	namespace:decode_compressed
squaredErrors	./apps/CF.C	/^double* squaredErrors;$/;"	v
srcTarg	./apps/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseForwardT
srcTarg	./apps/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseT
srcTarg	./apps/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::sparseT
srcTarg	./apps/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseForwardT
srcTarg	./apps/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseT
srcTarg	./apps/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::sparseT
srcTarg	./ligra/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseForwardT
srcTarg	./ligra/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseT
srcTarg	./ligra/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::sparseT
srcTarg	./ligra/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseForwardT
srcTarg	./ligra/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseT
srcTarg	./ligra/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::sparseT
srcTarg	./tutorial/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseForwardT
srcTarg	./tutorial/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseT
srcTarg	./tutorial/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const intE &weight, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::sparseT
srcTarg	./tutorial/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseForwardT
srcTarg	./tutorial/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::denseT
srcTarg	./tutorial/compressedVertex.h	/^    inline bool srcTarg(F &f, const uintE &src, const uintE &target, const uintT &edgeNumber) {$/;"	f	struct:decode_compressed::sparseT
start	./apps/gettime.h	/^  void start () {$/;"	f	struct:timer
start	./ligra/gettime.h	/^  void start () {$/;"	f	struct:timer
start	./tutorial/gettime.h	/^  void start () {$/;"	f	struct:timer
startTime	./apps/gettime.h	109;"	d
startTime	./ligra/gettime.h	109;"	d
startTime	./tutorial/gettime.h	109;"	d
step	./apps/CF.C	/^  double step, lambda;$/;"	m	struct:CF_Vertex_F	file:
stop	./apps/gettime.h	/^  double stop () {$/;"	f	struct:timer
stop	./apps/gettime.h	/^  double stop (double weight) {$/;"	f	struct:timer
stop	./ligra/gettime.h	/^  double stop () {$/;"	f	struct:timer
stop	./ligra/gettime.h	/^  double stop (double weight) {$/;"	f	struct:timer
stop	./tutorial/gettime.h	/^  double stop () {$/;"	f	struct:timer
stop	./tutorial/gettime.h	/^  double stop (double weight) {$/;"	f	struct:timer
stopTime	./apps/gettime.h	110;"	d
stopTime	./ligra/gettime.h	110;"	d
stopTime	./tutorial/gettime.h	110;"	d
stringToWords	./apps/IO.h	/^words stringToWords(char *Str, long n) {$/;"	f
stringToWords	./ligra/IO.h	/^words stringToWords(char *Str, long n) {$/;"	f
stringToWords	./tutorial/IO.h	/^words stringToWords(char *Str, long n) {$/;"	f
stringToWords	./utils/graphIO.h	/^  words stringToWords(char *Str, long n) {$/;"	f	namespace:benchIO
sum	./apps/utils.h	/^  intT sum(bool *In, intT n) {$/;"	f	namespace:sequence
sum	./ligra/utils.h	/^  intT sum(bool *In, intT n) {$/;"	f	namespace:sequence
sum	./tutorial/utils.h	/^  intT sum(bool *In, intT n) {$/;"	f	namespace:sequence
sum	./utils/utils.h	/^  intT sum(bool *In, intT n) {$/;"	f	namespace:sequence
sumFlagsSerial	./apps/utils.h	/^  intT sumFlagsSerial(bool *Fl, intT n) {$/;"	f	namespace:sequence
sumFlagsSerial	./ligra/utils.h	/^  intT sumFlagsSerial(bool *Fl, intT n) {$/;"	f	namespace:sequence
sumFlagsSerial	./tutorial/utils.h	/^  intT sumFlagsSerial(bool *Fl, intT n) {$/;"	f	namespace:sequence
sumFlagsSerial	./utils/utils.h	/^  intT sumFlagsSerial(bool *Fl, intT n) {$/;"	f	namespace:sequence
sweepCut	./apps/localAlg/sweep.h	/^  sweepObject sweepCut(graph<vertex>& GA, pair<uintE,fType> *p, long numNonzeros, long start) {  $/;"	f
sweepObject	./apps/localAlg/sweep.h	/^struct sweepObject {$/;"	s
sweepObject	./apps/localAlg/sweep.h	/^sweepObject(double _c, long _s, long _volS, long _vol, long _e) :$/;"	f	struct:sweepObject
sweep_compare	./apps/localAlg/sweep.h	/^struct sweep_compare { $/;"	s
sweep_compare	./apps/localAlg/sweep.h	/^sweep_compare(vertex* _V) : V(_V) {}$/;"	f	struct:sweep_compare
symmetricVertex	./apps/vertex.h	/^struct symmetricVertex {$/;"	s
symmetricVertex	./apps/vertex.h	/^symmetricVertex(uintE* n, uintT d) $/;"	f	struct:symmetricVertex
symmetricVertex	./ligra/vertex.h	/^struct symmetricVertex {$/;"	s
symmetricVertex	./ligra/vertex.h	/^symmetricVertex(uintE* n, uintT d) $/;"	f	struct:symmetricVertex
symmetricVertex	./tutorial/vertex.h	/^struct symmetricVertex {$/;"	s
symmetricVertex	./tutorial/vertex.h	/^symmetricVertex(uintE* n, uintT d) $/;"	f	struct:symmetricVertex
t0	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t0	./apps/eccentricity/FM-Ecc.C	/^timer t0,t1,t2;$/;"	v
t0	./apps/eccentricity/LogLog-Ecc.C	/^timer t0,t1,t2;$/;"	v
t0	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t0	./apps/eccentricity/Simple-Approx-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t0	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t0	./apps/eccentricity/kBFS-Ecc.C	/^timer t0,t1,t2,t3,t4,t5;$/;"	v
t0	./apps/eccentricity/kBFS-Exact.C	/^timer t0;$/;"	v
t1	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t1	./apps/eccentricity/FM-Ecc.C	/^timer t0,t1,t2;$/;"	v
t1	./apps/eccentricity/LogLog-Ecc.C	/^timer t0,t1,t2;$/;"	v
t1	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t1	./apps/eccentricity/Simple-Approx-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t1	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t1	./apps/eccentricity/kBFS-Ecc.C	/^timer t0,t1,t2,t3,t4,t5;$/;"	v
t1	./apps/localAlg/ACL-Serial-Naive.C	/^timer t1;$/;"	v
t1	./apps/localAlg/ACL-Serial-Opt-Naive.C	/^timer t1;$/;"	v
t1	./apps/localAlg/ACL-Serial-Opt.C	/^timer t1;$/;"	v
t1	./apps/localAlg/ACL-Serial.C	/^timer t1;$/;"	v
t1	./apps/localAlg/ACL-Sync-Local-Opt.C	/^timer t1;$/;"	v
t1	./apps/localAlg/ACL-Sync-Local.C	/^timer t1;$/;"	v
t1	./apps/localAlg/HeatKernel-Parallel.C	/^timer t1;$/;"	v
t1	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^timer t1;$/;"	v
t1	./apps/localAlg/HeatKernel-Randomized-Serial.C	/^timer t1;$/;"	v
t1	./apps/localAlg/HeatKernel-Serial.C	/^timer t1;$/;"	v
t1	./apps/localAlg/Nibble-Parallel.C	/^timer t1;$/;"	v
t1	./apps/localAlg/Nibble-Serial.C	/^timer t1;$/;"	v
t10	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t10	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t2	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t2	./apps/eccentricity/FM-Ecc.C	/^timer t0,t1,t2;$/;"	v
t2	./apps/eccentricity/LogLog-Ecc.C	/^timer t0,t1,t2;$/;"	v
t2	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t2	./apps/eccentricity/Simple-Approx-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t2	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t2	./apps/eccentricity/kBFS-Ecc.C	/^timer t0,t1,t2,t3,t4,t5;$/;"	v
t3	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t3	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t3	./apps/eccentricity/Simple-Approx-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t3	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^timer t0,t1,t2,t3;$/;"	v
t3	./apps/eccentricity/kBFS-Ecc.C	/^timer t0,t1,t2,t3,t4,t5;$/;"	v
t4	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t4	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t4	./apps/eccentricity/kBFS-Ecc.C	/^timer t0,t1,t2,t3,t4,t5;$/;"	v
t5	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t5	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t5	./apps/eccentricity/kBFS-Ecc.C	/^timer t0,t1,t2,t3,t4,t5;$/;"	v
t6	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t6	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t7	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t7	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t8	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t8	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t9	./apps/eccentricity/CLRSTV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
t9	./apps/eccentricity/RV.C	/^timer t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;$/;"	v
timeStatement	./apps/gettime.h	108;"	d
timeStatement	./ligra/gettime.h	108;"	d
timeStatement	./tutorial/gettime.h	108;"	d
timer	./apps/gettime.h	/^  timer() {$/;"	f	struct:timer
timer	./apps/gettime.h	/^struct timer {$/;"	s
timer	./ligra/gettime.h	/^  timer() {$/;"	f	struct:timer
timer	./ligra/gettime.h	/^struct timer {$/;"	s
timer	./tutorial/gettime.h	/^  timer() {$/;"	f	struct:timer
timer	./tutorial/gettime.h	/^struct timer {$/;"	s
toDense	./apps/vertexSubset.h	/^  void toDense() {$/;"	f	struct:vertexSubset
toDense	./ligra/vertexSubset.h	/^  void toDense() {$/;"	f	struct:vertexSubset
toDense	./tutorial/vertexSubset.h	/^  void toDense() {$/;"	f	struct:vertexSubset
toLong	./utils/graphIO.h	/^  struct toLong { long operator() (bool v) {return (long) v;} };$/;"	s	namespace:benchIO
toSparse	./apps/vertexSubset.h	/^  void toSparse() {$/;"	f	struct:vertexSubset
toSparse	./ligra/vertexSubset.h	/^  void toSparse() {$/;"	f	struct:vertexSubset
toSparse	./tutorial/vertexSubset.h	/^  void toSparse() {$/;"	f	struct:vertexSubset
toSubtract	./apps/localAlg/ACL-Sync-Local.C	/^  double alpha, toSubtract;$/;"	m	struct:Local_Update	file:
total	./apps/gettime.h	/^  double total() {$/;"	f	struct:timer
total	./ligra/gettime.h	/^  double total() {$/;"	f	struct:timer
total	./tutorial/gettime.h	/^  double total() {$/;"	f	struct:timer
totalTime	./apps/gettime.h	/^  double totalTime;$/;"	m	struct:timer
totalTime	./ligra/gettime.h	/^  double totalTime;$/;"	m	struct:timer
totalTime	./tutorial/gettime.h	/^  double totalTime;$/;"	m	struct:timer
totalWeight	./apps/gettime.h	/^  double totalWeight;$/;"	m	struct:timer
totalWeight	./ligra/gettime.h	/^  double totalWeight;$/;"	m	struct:timer
totalWeight	./tutorial/gettime.h	/^  double totalWeight;$/;"	m	struct:timer
toverjplus1	./apps/localAlg/HeatKernel-Parallel.C	/^  double toverjplus1;$/;"	m	struct:HK_F	file:
trans	./apps/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:blockTrans
trans	./apps/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:transpose
trans	./ligra/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:blockTrans
trans	./ligra/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:transpose
trans	./tutorial/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:blockTrans
trans	./tutorial/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:transpose
trans	./utils/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:blockTrans
trans	./utils/transpose.h	/^  void trans(intT rCount, intT cCount) {$/;"	f	struct:transpose
transR	./apps/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:blockTrans
transR	./apps/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:transpose
transR	./ligra/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:blockTrans
transR	./ligra/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:transpose
transR	./tutorial/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:blockTrans
transR	./tutorial/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:transpose
transR	./utils/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:blockTrans
transR	./utils/transpose.h	/^  void transR(intT rStart, intT rCount, intT rLength,$/;"	f	struct:transpose
transpose	./apps/graph.h	/^  void transpose() {$/;"	f	struct:graph
transpose	./apps/transpose.h	/^  transpose(E *AA, E *BB) : A(AA), B(BB) {}$/;"	f	struct:transpose
transpose	./apps/transpose.h	/^struct transpose {$/;"	s
transpose	./ligra/graph.h	/^  void transpose() {$/;"	f	struct:graph
transpose	./ligra/transpose.h	/^  transpose(E *AA, E *BB) : A(AA), B(BB) {}$/;"	f	struct:transpose
transpose	./ligra/transpose.h	/^struct transpose {$/;"	s
transpose	./tutorial/graph.h	/^  void transpose() {$/;"	f	struct:graph
transpose	./tutorial/transpose.h	/^  transpose(E *AA, E *BB) : A(AA), B(BB) {}$/;"	f	struct:transpose
transpose	./tutorial/transpose.h	/^struct transpose {$/;"	s
transpose	./utils/transpose.h	/^  transpose(E *AA, E *BB) : A(AA), B(BB) {}$/;"	f	struct:transpose
transpose	./utils/transpose.h	/^struct transpose {$/;"	s
transposed	./apps/graph.h	/^  bool transposed;$/;"	m	struct:graph
transposed	./ligra/graph.h	/^  bool transposed;$/;"	m	struct:graph
transposed	./tutorial/graph.h	/^  bool transposed;$/;"	m	struct:graph
tripleCmp	./apps/encoder.C	/^struct tripleCmp {$/;"	s	file:
tripleCmp	./ligra/encoder.C	/^struct tripleCmp {$/;"	s	file:
tripleCmp	./tutorial/encoder.C	/^struct tripleCmp {$/;"	s	file:
twoAlphaOverOnePlusAlpha	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  double twoAlphaOverOnePlusAlpha;$/;"	m	struct:Local_Update	file:
tzp	./apps/gettime.h	/^  struct timezone tzp;$/;"	m	struct:timer	typeref:struct:timer::timezone
tzp	./ligra/gettime.h	/^  struct timezone tzp;$/;"	m	struct:timer	typeref:struct:timer::timezone
tzp	./tutorial/gettime.h	/^  struct timezone tzp;$/;"	m	struct:timer	typeref:struct:timer::timezone
u	./utils/graphIO.h	/^  intT u;$/;"	m	struct:edge
uchar	./apps/byte-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./apps/byte.h	/^typedef unsigned char uchar;$/;"	t
uchar	./apps/byteRLE-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./apps/byteRLE.h	/^typedef unsigned char uchar;$/;"	t
uchar	./apps/nibble-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./apps/nibble.h	/^typedef unsigned char uchar;$/;"	t
uchar	./ligra/byte-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./ligra/byte.h	/^typedef unsigned char uchar;$/;"	t
uchar	./ligra/byteRLE-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./ligra/byteRLE.h	/^typedef unsigned char uchar;$/;"	t
uchar	./ligra/nibble-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./ligra/nibble.h	/^typedef unsigned char uchar;$/;"	t
uchar	./tutorial/byte-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./tutorial/byte.h	/^typedef unsigned char uchar;$/;"	t
uchar	./tutorial/byteRLE-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./tutorial/byteRLE.h	/^typedef unsigned char uchar;$/;"	t
uchar	./tutorial/nibble-pd.h	/^typedef unsigned char uchar;$/;"	t
uchar	./tutorial/nibble.h	/^typedef unsigned char uchar;$/;"	t
uint	./apps/utils.h	43;"	d
uint	./ligra/utils.h	43;"	d
uint	./tutorial/utils.h	43;"	d
uint	./utils/utils.h	43;"	d
uintE	./apps/parallel.h	/^typedef unsigned int uintE;$/;"	t
uintE	./apps/parallel.h	/^typedef unsigned long uintE;$/;"	t
uintE	./ligra/parallel.h	/^typedef unsigned int uintE;$/;"	t
uintE	./ligra/parallel.h	/^typedef unsigned long uintE;$/;"	t
uintE	./tutorial/parallel.h	/^typedef unsigned int uintE;$/;"	t
uintE	./tutorial/parallel.h	/^typedef unsigned long uintE;$/;"	t
uintE	./utils/parallel.h	/^typedef unsigned int uintE;$/;"	t
uintE	./utils/parallel.h	/^typedef unsigned long uintE;$/;"	t
uintT	./apps/parallel.h	/^typedef unsigned int uintT;$/;"	t
uintT	./apps/parallel.h	/^typedef unsigned long uintT;$/;"	t
uintT	./ligra/parallel.h	/^typedef unsigned int uintT;$/;"	t
uintT	./ligra/parallel.h	/^typedef unsigned long uintT;$/;"	t
uintT	./tutorial/parallel.h	/^typedef unsigned int uintT;$/;"	t
uintT	./tutorial/parallel.h	/^typedef unsigned long uintT;$/;"	t
uintT	./utils/parallel.h	/^typedef unsigned int uintT;$/;"	t
uintT	./utils/parallel.h	/^typedef unsigned long uintT;$/;"	t
ulong	./apps/utils.h	47;"	d
ulong	./ligra/utils.h	47;"	d
ulong	./tutorial/utils.h	47;"	d
ulong	./utils/utils.h	47;"	d
update	./apps/BC.C	/^  inline bool update(uintE s, uintE d){ \/\/Update function for backwards phase$/;"	f	struct:BC_Back_F
update	./apps/BC.C	/^  inline bool update(uintE s, uintE d){ \/\/Update function for forward phase$/;"	f	struct:BC_F
update	./apps/BFS-Bitvector.C	/^  inline bool update (uintE s, uintE d) { \/\/Update$/;"	f	struct:BFS_F
update	./apps/BFS.C	/^  inline bool update (uintE s, uintE d) { \/\/Update$/;"	f	struct:BFS_F
update	./apps/BFSCC.C	/^  inline bool update (uintE s, uintE d) { \/\/Update$/;"	f	struct:BFS_F
update	./apps/BellmanFord.C	/^  inline bool update (uintE s, uintE d, intE edgeLen) { \/\/Update ShortestPathLen if found a shorter path$/;"	f	struct:BF_F
update	./apps/CF.C	/^  inline bool update(uintE s, uintE d, intE edgeLen){ \/\/updates latent vector based on neighbors' data$/;"	f	struct:CF_Edge_F
update	./apps/Components.C	/^  inline bool update(uintE s, uintE d){ \/\/Update function writes min ID$/;"	f	struct:CC_F
update	./apps/KCore.C	/^  inline bool update (uintE s, uintE d) { $/;"	f	struct:Update_Deg
update	./apps/MIS.C	/^  inline bool update (uintE s, uintE d) {$/;"	f	struct:MIS_Update
update	./apps/MaxDegree.C	/^    inline bool update(uintE s, uintE d){$/;"	f	struct:MAXDEG_F
update	./apps/MaxDegree.C	/^  inline bool update (uintE s, uintE d) { \/\/Update$/;"	f	struct:BFS_F
update	./apps/PageRank.C	/^  inline bool update(uintE s, uintE d){ \/\/update function applies PageRank equation$/;"	f	struct:PR_F
update	./apps/PageRankDelta.C	/^  inline bool update(uintE s, uintE d){$/;"	f	struct:PR_F
update	./apps/Radii.C	/^  inline bool update (uintE s, uintE d){ \/\/Update function does a bitwise-or$/;"	f	struct:Radii_F
update	./apps/Triangle.C	/^  inline bool update (uintE s, uintE d) {$/;"	f	struct:countF
update	./apps/eccentricity/CCBFS.h	/^  inline bool update(const intE &s, const intE& d) {$/;"	f	struct:CCBFS_F
update	./apps/eccentricity/CCBFS.h	/^  inline bool update(const uintE &s, const uintE &d){ $/;"	f	struct:CC_F
update	./apps/eccentricity/CLRSTV.C	/^  inline bool update(const uintE &s, const uintE& d) {$/;"	f	struct:BFS_F
update	./apps/eccentricity/FM-Ecc.C	/^  inline bool update(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
update	./apps/eccentricity/LogLog-Ecc.C	/^  inline bool update(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
update	./apps/eccentricity/RV.C	/^  inline bool update(const uintE &s, const uintE& d) {$/;"	f	struct:BFS_F
update	./apps/eccentricity/RV.C	/^  inline bool update(const uintE &s, const uintE& d) {$/;"	f	struct:BFS_Pair_F
update	./apps/eccentricity/Simple-Approx-Ecc.C	/^  inline bool update(const uintE &s, const uintE& d) {$/;"	f	struct:BFS_F
update	./apps/eccentricity/TK.C	/^  inline bool update(const uintE &s, const uintE& d) {$/;"	f	struct:BFS_F
update	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  inline bool update(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
update	./apps/eccentricity/kBFS-Ecc.C	/^  inline bool update(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
update	./apps/eccentricity/kBFS-Exact.C	/^  inline bool update(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
update	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  inline bool update(uintE s, uintE d){ \/\/update function applies PageRank equation$/;"	f	struct:ACL_F
update	./apps/localAlg/ACL-Sync-Local.C	/^  inline bool update(uintE s, uintE d){ \/\/update function applies PageRank equation$/;"	f	struct:ACL_F
update	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool update(uintE s, uintE d){$/;"	f	struct:HK_F
update	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool update(uintE s, uintE d){$/;"	f	struct:HK_Last_F
update	./apps/localAlg/Nibble-Parallel.C	/^  inline bool update(uintE s, uintE d){ \/\/update function applies PageRank equation$/;"	f	struct:Nibble_F
update	./tutorial/BFS.C	/^  inline bool update (long s, long d) { \/\/Update$/;"	f	struct:BFS_F
update	./tutorial/BellmanFord.C	/^  inline bool update (long s, long d, long edgeLen) {$/;"	f	struct:BF_F
update	./tutorial/Components.C	/^  inline bool update(long s, long d){ $/;"	f	struct:CC_F
update	./tutorial/KCore.C	/^  inline bool update (long s, long d) { $/;"	f	struct:Update_Deg
update	./tutorial/Radii.C	/^  inline bool update (long s, long d){$/;"	f	struct:Radii_F
updateAtomic	./apps/BC.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:BC_Back_F
updateAtomic	./apps/BC.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update, basically an add$/;"	f	struct:BC_F
updateAtomic	./apps/BFS-Bitvector.C	/^  inline bool updateAtomic (uintE s, uintE d){ \/\/atomic version of Update$/;"	f	struct:BFS_F
updateAtomic	./apps/BFS.C	/^  inline bool updateAtomic (uintE s, uintE d){ \/\/atomic version of Update$/;"	f	struct:BFS_F
updateAtomic	./apps/BFSCC.C	/^  inline bool updateAtomic (uintE s, uintE d){ \/\/atomic version of Update$/;"	f	struct:BFS_F
updateAtomic	./apps/BellmanFord.C	/^  inline bool updateAtomic (uintE s, uintE d, intE edgeLen){ \/\/atomic Update$/;"	f	struct:BF_F
updateAtomic	./apps/CF.C	/^  inline bool updateAtomic (uintE s, uintE d, intE edgeLen) {$/;"	f	struct:CF_Edge_F
updateAtomic	./apps/Components.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:CC_F
updateAtomic	./apps/KCore.C	/^  inline bool updateAtomic (uintE s, uintE d){$/;"	f	struct:Update_Deg
updateAtomic	./apps/MIS.C	/^  inline bool updateAtomic (uintE s, uintE d) {$/;"	f	struct:MIS_Update
updateAtomic	./apps/MaxDegree.C	/^    inline bool updateAtomic(uintE s, uintE d){$/;"	f	struct:MAXDEG_F
updateAtomic	./apps/MaxDegree.C	/^  inline bool updateAtomic (uintE s, uintE d){ \/\/atomic version of Update$/;"	f	struct:BFS_F
updateAtomic	./apps/PageRank.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:PR_F
updateAtomic	./apps/PageRankDelta.C	/^  inline bool updateAtomic (uintE s, uintE d) {$/;"	f	struct:PR_F
updateAtomic	./apps/Radii.C	/^  inline bool updateAtomic (uintE s, uintE d){ \/\/atomic Update$/;"	f	struct:Radii_F
updateAtomic	./apps/Triangle.C	/^  inline bool updateAtomic (uintE s, uintE d) {$/;"	f	struct:countF
updateAtomic	./apps/eccentricity/CCBFS.h	/^  inline bool updateAtomic(const intE &s, const intE &d) {$/;"	f	struct:CCBFS_F
updateAtomic	./apps/eccentricity/CCBFS.h	/^  inline bool updateAtomic(const uintE &s, const uintE &d){ $/;"	f	struct:CC_F
updateAtomic	./apps/eccentricity/CLRSTV.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d) {$/;"	f	struct:BFS_F
updateAtomic	./apps/eccentricity/FM-Ecc.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
updateAtomic	./apps/eccentricity/LogLog-Ecc.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
updateAtomic	./apps/eccentricity/RV.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d) {$/;"	f	struct:BFS_F
updateAtomic	./apps/eccentricity/RV.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d) {$/;"	f	struct:BFS_Pair_F
updateAtomic	./apps/eccentricity/Simple-Approx-Ecc.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d) {$/;"	f	struct:BFS_F
updateAtomic	./apps/eccentricity/TK.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d) {$/;"	f	struct:BFS_F
updateAtomic	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
updateAtomic	./apps/eccentricity/kBFS-Ecc.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
updateAtomic	./apps/eccentricity/kBFS-Exact.C	/^  inline bool updateAtomic(const uintE &s, const uintE &d){$/;"	f	struct:Ecc_F
updateAtomic	./apps/localAlg/ACL-Sync-Local-Opt.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:ACL_F
updateAtomic	./apps/localAlg/ACL-Sync-Local.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:ACL_F
updateAtomic	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:HK_F
updateAtomic	./apps/localAlg/HeatKernel-Parallel.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:HK_Last_F
updateAtomic	./apps/localAlg/Nibble-Parallel.C	/^  inline bool updateAtomic (uintE s, uintE d) { \/\/atomic Update$/;"	f	struct:Nibble_F
updateAtomic	./tutorial/BFS.C	/^  inline bool updateAtomic (long s, long d){ \/\/atomic version of Update$/;"	f	struct:BFS_F
updateAtomic	./tutorial/BellmanFord.C	/^  inline bool updateAtomic (long s, long d, long edgeLen){ \/\/atomic Update$/;"	f	struct:BF_F
updateAtomic	./tutorial/Components.C	/^  inline bool updateAtomic (long s, long d) { \/\/atomic Update$/;"	f	struct:CC_F
updateAtomic	./tutorial/KCore.C	/^  inline bool updateAtomic (long s, long d){$/;"	f	struct:Update_Deg
updateAtomic	./tutorial/Radii.C	/^  inline bool updateAtomic (long s, long d){ \/\/atomic Update$/;"	f	struct:Radii_F
upper	./apps/eccentricity/Simple-Approx-Ecc.C	/^  uintE* upper;$/;"	m	struct:max_upper	file:
upper	./apps/eccentricity/TK.C	/^  uintE* upper;$/;"	m	struct:max_upper	file:
v	./apps/compressedVertex.h	/^    uintT v, o;$/;"	m	struct:decode_compressed::sparseT
v	./ligra/compressedVertex.h	/^    uintT v, o;$/;"	m	struct:decode_compressed::sparseT
v	./tutorial/compressedVertex.h	/^    uintT v, o;$/;"	m	struct:decode_compressed::sparseT
v	./utils/graphIO.h	/^  intT v;$/;"	m	struct:edge
vertex	./utils/graphIO.h	/^  vertex(intT* N, intT d) : Neighbors(N), degree(d) {}$/;"	f	struct:vertex
vertex	./utils/graphIO.h	/^struct vertex {$/;"	s
vertexArr	./apps/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseForwardT
vertexArr	./apps/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseT
vertexArr	./ligra/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseForwardT
vertexArr	./ligra/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseT
vertexArr	./tutorial/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseForwardT
vertexArr	./tutorial/compressedVertex.h	/^    bool* nextArr, *vertexArr;$/;"	m	struct:decode_compressed::denseT
vertexFilter	./apps/ligra.h	/^vertexSubset vertexFilter(vertexSubset V, F filter) {$/;"	f
vertexFilter	./ligra/ligra.h	/^vertexSubset vertexFilter(vertexSubset V, F filter) {$/;"	f
vertexFilter	./tutorial/ligra.h	/^vertexSubset vertexFilter(vertexSubset V, F filter) {$/;"	f
vertexMap	./apps/ligra.h	/^void vertexMap(vertexSubset V, F add) {$/;"	f
vertexMap	./ligra/ligra.h	/^void vertexMap(vertexSubset V, F add) {$/;"	f
vertexMap	./tutorial/ligra.h	/^void vertexMap(vertexSubset V, F add) {$/;"	f
vertexSubset	./apps/vertexSubset.h	/^struct vertexSubset {$/;"	s
vertexSubset	./apps/vertexSubset.h	/^vertexSubset(long _n) : n(_n), m(0), d(NULL), s(NULL), isDense(0) {}$/;"	f	struct:vertexSubset
vertexSubset	./apps/vertexSubset.h	/^vertexSubset(long _n, bool* bits) $/;"	f	struct:vertexSubset
vertexSubset	./apps/vertexSubset.h	/^vertexSubset(long _n, intE v) $/;"	f	struct:vertexSubset
vertexSubset	./apps/vertexSubset.h	/^vertexSubset(long _n, long _m, bool* bits) $/;"	f	struct:vertexSubset
vertexSubset	./apps/vertexSubset.h	/^vertexSubset(long _n, long _m, uintE* indices) $/;"	f	struct:vertexSubset
vertexSubset	./ligra/vertexSubset.h	/^struct vertexSubset {$/;"	s
vertexSubset	./ligra/vertexSubset.h	/^vertexSubset(long _n) : n(_n), m(0), d(NULL), s(NULL), isDense(0) {}$/;"	f	struct:vertexSubset
vertexSubset	./ligra/vertexSubset.h	/^vertexSubset(long _n, bool* bits) $/;"	f	struct:vertexSubset
vertexSubset	./ligra/vertexSubset.h	/^vertexSubset(long _n, intE v) $/;"	f	struct:vertexSubset
vertexSubset	./ligra/vertexSubset.h	/^vertexSubset(long _n, long _m, bool* bits) $/;"	f	struct:vertexSubset
vertexSubset	./ligra/vertexSubset.h	/^vertexSubset(long _n, long _m, uintE* indices) $/;"	f	struct:vertexSubset
vertexSubset	./tutorial/vertexSubset.h	/^struct vertexSubset {$/;"	s
vertexSubset	./tutorial/vertexSubset.h	/^vertexSubset(long _n) : n(_n), m(0), d(NULL), s(NULL), isDense(0) {}$/;"	f	struct:vertexSubset
vertexSubset	./tutorial/vertexSubset.h	/^vertexSubset(long _n, bool* bits) $/;"	f	struct:vertexSubset
vertexSubset	./tutorial/vertexSubset.h	/^vertexSubset(long _n, intE v) $/;"	f	struct:vertexSubset
vertexSubset	./tutorial/vertexSubset.h	/^vertexSubset(long _n, long _m, bool* bits) $/;"	f	struct:vertexSubset
vertexSubset	./tutorial/vertexSubset.h	/^vertexSubset(long _n, long _m, uintE* indices) $/;"	f	struct:vertexSubset
vertices	./utils/graphIO.h	/^  intT* vertices() { return allocatedInplace+2; }$/;"	f	struct:graph
vol	./apps/localAlg/sweep.h	/^  long sizeS, volS, vol, edgesCrossing;$/;"	m	struct:sweepObject
volS	./apps/localAlg/sweep.h	/^  long sizeS, volS, vol, edgesCrossing;$/;"	m	struct:sweepObject
walk	./apps/localAlg/HeatKernel-Randomized-Parallel.C	/^inline uintE walk(uintE x, vertex* V, uintE seed) {$/;"	f
walk	./apps/localAlg/HeatKernel-Randomized-Serial.C	/^inline uintE walk(uintE x, vertex* V, uintE seed) {$/;"	f
weights	./utils/graphIO.h	/^  intT* weights;$/;"	m	struct:wghGraph
wghGraph	./utils/graphIO.h	/^struct wghGraph {$/;"	s
wghGraph	./utils/graphIO.h	/^wghGraph(wghVertex<intT>* VV, intT nn, uintT mm) $/;"	f	struct:wghGraph
wghGraph	./utils/graphIO.h	/^wghGraph(wghVertex<intT>* VV, intT nn, uintT mm, intT* ai, intT* _weights) $/;"	f	struct:wghGraph
wghVertex	./utils/graphIO.h	/^struct wghVertex {$/;"	s
wghVertex	./utils/graphIO.h	/^wghVertex(intT* N, intT* W, intT d) : Neighbors(N), nghWeights(W), degree(d) {}$/;"	f	struct:wghVertex
words	./apps/IO.h	/^  words() {}$/;"	f	struct:words
words	./apps/IO.h	/^struct words {$/;"	s
words	./apps/IO.h	/^words(char* C, long nn, char** S, long mm)$/;"	f	struct:words
words	./ligra/IO.h	/^  words() {}$/;"	f	struct:words
words	./ligra/IO.h	/^struct words {$/;"	s
words	./ligra/IO.h	/^words(char* C, long nn, char** S, long mm)$/;"	f	struct:words
words	./tutorial/IO.h	/^  words() {}$/;"	f	struct:words
words	./tutorial/IO.h	/^struct words {$/;"	s
words	./tutorial/IO.h	/^words(char* C, long nn, char** S, long mm)$/;"	f	struct:words
words	./utils/graphIO.h	/^    words() {}$/;"	f	struct:benchIO::words
words	./utils/graphIO.h	/^    words(char* C, long nn, char** S, long mm)$/;"	f	struct:benchIO::words
words	./utils/graphIO.h	/^  struct words {$/;"	s	namespace:benchIO
writeAdd	./apps/utils.h	/^inline void writeAdd(ET *a, ET b) {$/;"	f
writeAdd	./ligra/utils.h	/^inline void writeAdd(ET *a, ET b) {$/;"	f
writeAdd	./tutorial/utils.h	/^inline void writeAdd(ET *a, ET b) {$/;"	f
writeAdd	./utils/utils.h	/^inline void writeAdd(ET *a, ET b) {$/;"	f
writeArrayToFile	./utils/graphIO.h	/^    int writeArrayToFile(string header, T* A, long n, char* fileName) {$/;"	f	namespace:benchIO
writeArrayToStream	./utils/graphIO.h	/^  void writeArrayToStream(ofstream& os, T* A, long n) {$/;"	f	namespace:benchIO
writeBroadwordMax	./apps/eccentricity/LogLog-Ecc.C	/^inline bool writeBroadwordMax(long *a, long b) {$/;"	f
writeGraphToFile	./utils/graphIO.h	/^  int writeGraphToFile(graph<intT> G, char* fname) {$/;"	f	namespace:benchIO
writeMin	./apps/utils.h	/^inline bool writeMin(ET *a, ET b) {$/;"	f
writeMin	./ligra/utils.h	/^inline bool writeMin(ET *a, ET b) {$/;"	f
writeMin	./tutorial/utils.h	/^inline bool writeMin(ET *a, ET b) {$/;"	f
writeMin	./utils/utils.h	/^inline bool writeMin(ET *a, ET b) {$/;"	f
writeOr	./apps/BFS-Bitvector.C	/^inline void writeOr(ET *a, ET b) {$/;"	f
writeOr	./apps/Radii.C	/^inline void writeOr(ET *a, ET b) {$/;"	f
writeOr	./apps/eccentricity/FM-Ecc.C	/^inline void writeOr(ET *a, ET b) {$/;"	f
writeOr	./apps/eccentricity/kBFS-1Phase-Ecc.C	/^inline void writeOr(ET *a, ET b) {$/;"	f
writeOr	./apps/eccentricity/kBFS-Ecc.C	/^inline void writeOr(ET *a, ET b) {$/;"	f
writeOr	./apps/eccentricity/kBFS-Exact.C	/^inline void writeOr(ET *a, ET b) {$/;"	f
writeOr	./tutorial/Radii.C	/^inline void writeOr(ET *a, ET b) {$/;"	f
writeStringToFile	./utils/graphIO.h	/^  int writeStringToFile(char* S, long n, char* fileName) {$/;"	f	namespace:benchIO
writeWghGraphToFile	./utils/graphIO.h	/^  int writeWghGraphToFile(wghGraph<intT> G, char* fname) {$/;"	f	namespace:benchIO
x	./apps/localAlg/HeatKernel-Parallel.C	/^  sparseAdditiveSet<float> x, r, new_r;$/;"	m	struct:HK_F	file:
x	./apps/localAlg/HeatKernel-Parallel.C	/^  sparseAdditiveSet<float> x, r;$/;"	m	struct:HK_Last_F	file:
x	./apps/localAlg/HeatKernel-Parallel.C	/^  sparseAdditiveSet<float> x, r;$/;"	m	struct:Local_Update	file:
xLessEqualY	./apps/eccentricity/LogLog-Ecc.C	37;"	d	file:
xLessY	./apps/eccentricity/LogLog-Ecc.C	34;"	d	file:
xToString	./utils/graphIO.h	/^  inline void xToString(char* s, char* a) { sprintf(s,"%s",a);}$/;"	f	namespace:benchIO
xToString	./utils/graphIO.h	/^  inline void xToString(char* s, double a) { sprintf(s,"%.11le", a);}$/;"	f	namespace:benchIO
xToString	./utils/graphIO.h	/^  inline void xToString(char* s, int a) { sprintf(s,"%d",a);}$/;"	f	namespace:benchIO
xToString	./utils/graphIO.h	/^  inline void xToString(char* s, long a) { sprintf(s,"%ld",a);}$/;"	f	namespace:benchIO
xToString	./utils/graphIO.h	/^  inline void xToString(char* s, pair<A,B> a) { $/;"	f	namespace:benchIO
xToString	./utils/graphIO.h	/^  inline void xToString(char* s, uint a) { sprintf(s,"%u",a);}$/;"	f	namespace:benchIO
xToString	./utils/graphIO.h	/^  inline void xToString(char* s, unsigned long a) { sprintf(s,"%lu",a);}$/;"	f	namespace:benchIO
xToString	./utils/graphIO.h	/^void xToString(char* s, edge<intT> a) { $/;"	f
xToStringLen	./utils/graphIO.h	/^  inline int xToStringLen(char* a) { return strlen(a)+1;}$/;"	f	namespace:benchIO
xToStringLen	./utils/graphIO.h	/^  inline int xToStringLen(double a) { return 18;}$/;"	f	namespace:benchIO
xToStringLen	./utils/graphIO.h	/^  inline int xToStringLen(int a) { return 12;}$/;"	f	namespace:benchIO
xToStringLen	./utils/graphIO.h	/^  inline int xToStringLen(long a) { return 21;}$/;"	f	namespace:benchIO
xToStringLen	./utils/graphIO.h	/^  inline int xToStringLen(pair<A,B> a) { $/;"	f	namespace:benchIO
xToStringLen	./utils/graphIO.h	/^  inline int xToStringLen(unsigned long a) { return 21;}$/;"	f	namespace:benchIO
xToStringLen	./utils/graphIO.h	/^  inline uint xToStringLen(uint a) { return 12;}$/;"	f	namespace:benchIO
xToStringLen	./utils/graphIO.h	/^int xToStringLen(edge<intT> a) { $/;"	f
